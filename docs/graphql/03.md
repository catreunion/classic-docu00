---
sidebar_position: 3
---

You are here

    Home
    Reviews

Roland SE-02
Synthesizer

    Synthesizers > Sound Modules

By Gordon Reid
Published October 2017

Roland SE-02

The latest in the Boutique range is the result of an unexpected collaboration between Roland and Studio Electronics.

After a couple of tentative efforts, Roland seem to be getting the hang of collaboration. In 2015, the company struck up an arms-length relationship with Reon and a somewhat less hesitant one with the strangely named Malekko Heavy Industries. But while few seemed to understand the point of the Reon Driftbox-R, the Roland/Malekko System 500 — which is described as “built in the USA and assembled in Japan” — was an unmistakable homage to the Roland System 100M. Today, another collaboration (which, according to Studio Electronics, comes from long-standing friendship and mutual respect between the two companies) has given birth to the SE-02, which marries a Studio Electronics monosynth to a digital sequencer and delay within the diminutive form of Roland’s Boutique package.

Mind you, delving a little more deeply shows that the voicing in the SE-02 is rather less analogue than it first appears, with digital technology used in the tuning mechanism, the contour generators, the LFO and the portamento. This makes it a hybrid analogue/digital synth with an analogue signal path, which doesn’t bother me at all, but clearly makes Roland uncomfortable because they have chosen to overlook this in all of their product descriptions. Given Studio Electronics’ history of creating Moog-inspired synths comprising analogue signal paths controlled by digital modulators and contours, I was intrigued to see how far this particular apple had fallen from the tree.
The Technology

Described by Roland as “the debut product of the new Roland Boutique Designer Series”, the SE-02 uses the same case as previous Boutique modules, to the extent that it’s compatible with the K25m keyboard unit and the DK01 Boutique Dock. It also shares (for better or worse) things such as the 3.5mm sockets for its audio I/O. But you only have to spot the socket for a 9V DC power supply to realise that it’s different from the other Boutique modules... because it has one! While the previous models could run on the power supplied by a USB connection, the hungrier SE-02 cannot.

Visually, the SE-02 appears to be a response to the current craze for all things Minimoog-ish, and things such as its oscillator and filter structures as well as its ADS(D) contour generators make the comparison unavoidable. I therefore wondered whether it would feel and sound like a miniature but extended version of the Minimoog, and placed it next to my Minimoog to test it.

As you can see, it incorporates three oscillators, implemented as VCOs but with a digital tuning mechanism, which isn’t quite the contradiction in terms that it sounds. The six waveforms available on each (including the substitution of a ramp wave for the shark’s tooth wave in osc 3) are identical with the Moog’s, as are the footages, the fine-tune controls for osc 2 and osc 3, and the switch to disconnect osc 3 from the keyboard CV. Testing each of the waveforms with the filters wide open and no modulation or effects applied revealed that the underlying waveforms and tones are very similar to the Minimoog’s, although perhaps not quite as similar as emulations from elsewhere. I’m not surprised; just before submitting this review, I discovered that Studio Electronics have incorporated elements of Oberheim and ARP technology in the SE-02’s oscillators.

Other differences are more apparent. Some are operational, such as the master tune knob migrating from the Controllers panel on the Moog to the Oscillators panel of the SE-02, where it’s far too easy to nudge accidentally and send the whole instrument out of tune. But more significant are the additions to the oscillator architecture, including oscillator sync of osc 2 by osc 1, with the filter envelope sweeping osc 2 to obtain the usual range of aggressive hard-sync timbres, plus three cross-modulation options controlled using the dedicated XMod panel or the modulation wheel. The range of possibilities provided by these — individually or in combination — is immense, and the SE-02 is capable of generating sounds that no unmodified Minimoog ever could.

Next in the signal chain lies the mixer, which seems to offer level controls for five signal inputs. However, its appearance is deceiving because, where the external input volume control would lie on a Minimoog, there’s a knob to control the gain of a feedback loop (derived from Studio Electronics’ Boomstar range) that connects the output from the VCA to the mixer input. At low gains, the sound can become fatter and more assertive; at high gains with high signal levels it can pass through downright obnoxious all the way to out-of-control axe-wielding maniac. Consequently, any audio presented to the SE-02’s external signal input is injected into the signal path without any user control over its level. Oh yes, and the Minimoog’s white/pink noise switch has also been lost, and only white noise is generated.

Now comes the combined VCF/VCA section. This again mimics the Minimoog, with cutoff and emphasis controls for the 24dB/oct low-pass filter, and two switches to apply zero, 33, 67 or 100 percent keyboard tracking to the filter cutoff frequency. The Moog’s ADS(D) filter contour generator is also emulated, but now with an ‘invert’ option plus (yippee!) a multi-triggering option. I found that the filter itself sounded similar to the Minimoog’s, but with one obvious difference: the self-oscillation of the SE-02 filter goes down to 50Hz (which also seems to be the lowest cutoff frequency) while that of the Minimoog tails off at much higher frequencies. This means that some of the Minimoog’s characteristic bass sounds cannot be precisely replicated.

The VCA contour generator is also an ADS(D) device and, since there’s no performance panel, this is where you’ll find the switch to apply the decay time as a release phase. However, unlike the Minimoog, the SE-02 allows you determine whether the amplifier contour alone has a release phase, or whether both the filter and amplifier contours are affected. Another switch allows you to choose whether the rising edge of a gate signal (generated from a MIDI Note On or an incoming analogue gate from elsewhere) or the LFO triggers the contours. The fastest attack and release times are impressive, generating clicks at their minimum settings, but their slowest contour times, while not miserly, are not hugely generous. I timed all three phases on the SE-02 at around 14s, compared with around 14s (attack) and 40s (decay and Release) on my Minimoog. It’s not a problem, but will preclude unusually long, gentle sweeps. The VCA itself can be gently overdriven at high levels, which is nice.

The dedicated LFO section (again derived from the Boomstar series) appears to be next in the signal path (which, of course, it isn’t) and offers nine waveforms plus dedicated modulation routes to the oscillators’ master frequency and the filter cutoff frequency, each having its own knob to control the amount. Two switches then allow you to determine whether or not the LFO depth is controlled by the modulation wheel, and with either high or low amplitude. The low amplitude option is a welcome addition because the original Minimoog had a famously over-sensitive mod wheel when used for vibrato. Another switch determines whether the LFO runs freely, is sync’ed to key triggers, or produces a single ‘one-shot’ wave. Unfortunately, the last of these options, which should allow you to use the LFO as a simple contour generator, is knobbled by its implementation, which has the trigger point lying halfway between the minimum and maximum voltages. I think that Studio Electronics and Roland have missed a trick here. The final switch then determines whether the LFO is sync’d to MIDI Clock, or the delay is, or both are, which brings us neatly to...
Wait For It...

...The last stage in the signal path, which is a simple digital delay with time, regeneration and level controls. It seems almost too simple to be important, but it sounds great, and I found myself using it much more than I had anticipated.

All of the previous Boutique modules have included a sequencer, so it’s no surprise to find one in the SE-02. This is a monophonic, 16-step device that offers memories for 128 patterns that you can use to build songs of up to 16 Parts, where each Part comprises a patch, a pattern, and the number of times that the pattern is repeated. You can store up to 16 songs within the SE-02 itself, any of which you can load while a previous selection is playing.

Each step in a pattern (and, therefore, in a song) can contain a note number, a gate time, glide on/off and a change in the value of a single synth parameter value. Additional parameters include the choice of the first and last steps, the tempo, the direction in which the sequence is played (forward, backward, alternate and random), its destination (the internal sound engine, an external device or both), the sync source (internal, MIDI, USB or the trigger input), the internal tempo if used, the timing scale, the amount of shuffle, and whether the sequence is key-triggered or not. That’s a lot of sequencer in a small box!
The tightly packed front panel requires a certain amount of dexterity. On the other hand, it could be the perfect excuse to buy that trained lemur you’ve been thinking about...
The tightly packed front panel requires a certain amount of dexterity. On the other hand, it could be the perfect excuse to buy that trained lemur you’ve been thinking about...
In Use

Before I started using the SE-02 to make music, I noted a number of shortcomings. The most distressing of these was the fact that the oscillators in the review model weren’t scaled correctly and, across the oscillators’ range from 32’ to 2’, went flat by around 25 cents (half a semitone). This doesn’t sound like much, but it’s only the width of a 49-note keyboard, meaning that a sound that was in tune at the bottom was flat at the top. Since the tuning mechanism is based on a signal processing routine and a frequency look-up table there are no trimmers to tweak, so there was nothing that I could do about this.'

# mongoose

execute GraphQL queries on our server with Apollo Sandbox

mongoose [Mongoose v6.8.2: Getting Started](https://mongoosejs.com/docs/)

SPONSOR #native_company# — #native_desc#

First be sure you have MongoDB and Node.js installed.

```bash
npm install mongoose --save
```

Now say we like fuzzy kittens and want to record every kitten we ever meet in MongoDB. The first thing we need to do is include mongoose in our project and open a connection to the test database on our locally running instance of MongoDB.

// getting-started.js

```js
const mongoose = require("mongoose")

main().catch((err) => console.log(err))

async function main() {
  await mongoose.connect("mongodb://127.0.0.1:27017/test")

  // use `await mongoose.connect('mongodb://user:password@127.0.0.1:27017/test');` if your database has auth enabled
}
```

For brevity, let's assume that all following code is within the main() function.

With Mongoose, everything is derived from a Schema. Let's get a reference to it and define our kittens.

```js
const kittySchema = new mongoose.Schema({
  name: String
})
```

So far so good. We've got a schema with one property, name, which will be a String. The next step is compiling our schema into a Model.

```js
const Kitten = mongoose.model("Kitten", kittySchema)
```

A model is a class with which we construct documents. In this case, each document will be a kitten with properties and behaviors as declared in our schema. Let's create a kitten document representing the little guy we just met on the sidewalk outside:

```js
const silence = new Kitten({ name: "Silence" })
console.log(silence.name) // 'Silence'
```

Kittens can meow, so let's take a look at how to add "speak" functionality to our documents:

```js
// NOTE: methods must be added to the schema before compiling it with mongoose.model()
kittySchema.methods.speak = function speak() {
  const greeting = this.name ? "Meow name is " + this.name : "I don't have a name"
  console.log(greeting)
}

const Kitten = mongoose.model("Kitten", kittySchema)
```

Functions added to the methods property of a schema get compiled into the Model prototype and exposed on each document instance:

```js
const fluffy = new Kitten({ name: "fluffy" })
fluffy.speak() // "Meow name is fluffy"
```

We have talking kittens! But we still haven't saved anything to MongoDB. Each document can be saved to the database by calling its save method. The first argument to the callback will be an error if any occurred.

```js
await fluffy.save()
fluffy.speak()
```

Say time goes by and we want to display all the kittens we've seen. We can access all of the kitten documents through our Kitten model.

```js
const kittens = await Kitten.find()
console.log(kittens)
```

We just logged all of the kittens in our db to the console. If we want to filter our kittens by name, Mongoose supports MongoDBs rich querying syntax.

```js
await Kitten.find({ name: /^fluff/ })
```

This performs a search for all documents with a name property that begins with "fluff" and returns the result as an array of kittens to the callback.

Congratulations
That's the end of our quick start. We created a schema, added a custom document method, saved and queried kittens in MongoDB using Mongoose. Head over to the guide, or API docs for more.

---

A query language for your API
GraphQL is a query language for APIs and a runtime for fulfilling those queries with your existing data. GraphQL provides a complete and understandable description of the data in your API, gives clients the power to ask for exactly what they need and nothing more, makes it easier to evolve APIs over time, and enables powerful developer tools.

Ask for what you need, get exactly that

Send a GraphQL query to your API and get exactly what you need, nothing more and nothing less. GraphQL queries always return predictable results. Apps using GraphQL are fast and stable because they control the data they get, not the server.

```
{
  hero {
    name
    height
    mas
  }
}
{
  "hero": {
      "name": "Luke Skywalker",
      "height": 1.72
  }
}
```

Get many resources in a single request
GraphQL queries access not just the properties of one resource but also smoothly follow references between them. While typical REST APIs require loading from multiple URLs, GraphQL APIs get all the data your app needs in a single request. Apps using GraphQL can be quick even on slow mobile network connections.

```
{
    hero {
    name
    friends {
        name
        }
    }
}
{
    "hero": {
      "name": "Luke Skywalker",
      "friends": [
        { "name": "Obi-Wan Kenobi" },
        { "name": "R2-D2" },
        { "name": "Han Solo" },
        { "name": "Leia Organa" }
      ]
    }
}
```

Describe what’s possible with a type system
GraphQL APIs are organized in terms of types and fields, not endpoints. Access the full capabilities of your data from a single endpoint. GraphQL uses types to ensure Apps only ask for what’s possible and provide clear and helpful errors. Apps can use types to avoid writing manual parsing code.

```
{
  hero {
    name
    friends {
      name
      homeWorld {
        name
        climate
      }
      species {
        name
        lifespan
        origin {
          name
        }
      }
    }
  }
}

type Query {
  hero: Character
}

type Character {
  name: String
  friends: [Character]
  homeWorld: Planet
  species: Species
}

type Planet {
  name: String
  climate: String
}

type Species {
  name: String
  lifespan: Int
  origin: Planet
}
```

Move faster with powerful developer tools
Know exactly what data you can request from your API without leaving your editor, highlight potential issues before sending a query, and take advantage of improved code intelligence.

Evolve your API without versions

Add new fields and types to your GraphQL API without impacting existing queries. Aging fields can be deprecated and hidden from tools. By using a single evolving version, GraphQL APIs give apps continuous access to new features and encourage cleaner, more maintainable server code.

```
type Film {
  title: String
  episode: Int
  releaseDate: String
}

type Film {
  title: String
  episode: Int
  releaseDate: String
  openingCrawl: String
}

type Film {
  title: String
  episode: Int
  releaseDate: String
  openingCrawl: String
  director: String
}

type Film {
  title: String
  episode: Int
  releaseDate: String
  openingCrawl: String
  director: String
  directedBy: Person
}

type Person {
  name: String
  directed: [Film]
  actedIn: [Film]
}

type Film {
  title: String
  episode: Int
  releaseDate: String
  openingCrawl: String
  director: String @deprecated
  directedBy: Person
}
```

Bring your own data and code
GraphQL creates a uniform API across your entire application without being limited by a specific storage engine. Write GraphQL APIs that leverage your existing data and code with GraphQL engines available in many languages. You provide functions for each field in the type system, and GraphQL calls them with optimal concurrency.

```
type Character {
    name: String
    homeWorld: Planet
    friends: [Character]
}

// type Character {
class Character {
    // name: String
    getName() {
        return this._name
    }

    // homeWorld: Planet
    getHomeWorld() {
        return fetchHomeworld(this._homeworldID)
    }

    // friends: [Character]
    getFriends() {
        return this._friendIDs.map(fetchCharacter)
    }
}
# type Character {
class Character:
    # name: String
    def name(self):
        return self._name

    # homeWorld: Planet
    def homeWorld(self):
        return fetchHomeworld(self._homeworldID)

    # friends: [Character]
    def friends(self):
        return map(fetchCharacter, self._friendIDs)


// type Character {
public class Character {
  // name: String
  public String Name { get; }

  // homeWorld: Planet
  public async Task<Planet> GetHomeWorldAsync() {
    return await FetchHomeworldAsync(_HomeworldID);
  }

  // friends: [Character]
  public async IEnumerable<Task<Character>> GetFriendsAsync() {
    return _FriendIDs.Select(FetchCharacterAsync);
  }
}
```

## the useMutation React hook

Then, we return an object with the same properties as the object in the success case

When an error occurs, Apollo Server attaches an extensions field to that error that contains relevant error details.

The resolver handles both a successful response and possible errors. Which of these are true about the return objects for those two cases?

We start with the same assignSpaceship Mutation resolver example as in the previous code challenge. This time, we assume the dataSources.spaceAPI.assignSpaceshipToMission() call will return an error. Modify the following piece of code to properly handle the error returned by the API and return a properly formatted object that conforms to the schema definition of the AssignSpaceshipResponse type. Remember to use a try/catch block and to return dynamic error data when possible.

Now that we have our schema, data source, and resolvers set up with helpful mutation responses

Screenshot of Explorer with an empty Operation panel, ready for us to start building our query
Click the plus button (⊕) beside incrementTrackViews to add it to our Operation panel. This pre-fills some information for us! The syntax should feel familiar because it's the same syntax we've seen so far with our queries, particularly in Lift-off III where we used arguments and variables.

✍️ Building a GraphQL mutation

IncrementTrackViews : the mutation operation

incrementTrackViews : the mutation entry point

```
"Capital M is used for the Mutation type definition in the schema."
mutation IncrementTrackViews($incrementTrackViewsId: ID!) {
  incrementTrackViews(id: $incrementTrackViewsId) {
    code
    success
    message
    track {
      id
      numberOfViews
    }
  }
}
```

We use hooks to send requests to our GraphQL API from a React client. To send a mutation, we use the **useMutation** hook. This returns an **array**, where the first element is the **mutate function** used to trigger the mutation. The second element is an object with more information about the mutation, such as loading, error and **data**. This hook takes in a **GraphQL operation** as the first parameter. It also takes in an **options** object as the second parameter, where properties like **variables** are set.

The useQuery hook returns an array, whereas the useMutation hook returns an array.

The useQuery hook is used to send queries, whereas the useMutation hook is used to send mutation.

The useQuery hook runs automatically on component render, whereas the useMutation hook returns a mutate function needed to trigger the mutation.

```js
const ASSIGN_SPACESHIP_MUTATION = gql`
  mutation AssignSpaceshipToMissionMutation($spaceshipId: ID!, $missionId: ID!) {
    assignSpaceship(spaceshipId: $spaceshipId, missionId: $missionId) {
      code
      success
      message
      spaceship {
        name
      }
      mission {
        codename
      }
    }
  }
`

const spaceshipId = "ROCKET_X"
const missionId = "M0007"

const [assignSpaceship, { loading, error, data }] = useMutation(ASSIGN_SPACESHIP_MUTATION, {
  variables: { spaceshipId, missionId }
})
```

We want to update the number of views just before we navigate from the homepage to the track page. This navigation is happening inside our TrackCard component.

Because this is a mutation and not a query, we won't be using the useQuery hook we're familiar with.

Unlike with useQuery, calling useMutation doesn't actually execute the mutation automatically!

The useMutation hook returns an array with two elements, which we'll start to destructure here.

The first element is the mutate function we'll use to actually run the mutation later on.

When do we want to run our mutate function? When the user clicks on the card!

To do this, let's go back to where we set up our useMutation hook and add another property to our options object.

The onCompleted property is a callback function that will run when the mutation successfully completes, and it has access to the response that comes back. We'll log the response to the browser console.

variables: spaceshipId and missionId. Destructure the mutate function (call it assignSpaceship), as well as the loading, error and data properties from the return array of the hook.

Mutation was completed after the page was loaded
