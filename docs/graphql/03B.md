---
sidebar_position: 4
---

# End-To-End Type-Safety

index.html and Project Root

index.html is front-and-central instead of being tucked away inside public. This is intentional: during development Vite is a server, and index.html is the entry point to your application.

```text
Vite treats index.html as source code and part of the module graph. It resolves <script type="module" src="..."> that references your JavaScript source code. Even inline <script type="module"> and CSS referenced via <link href> also enjoy Vite-specific features. In addition, URLs inside index.html are automatically rebased so there's no need for special %PUBLIC_URL% placeholders.

Similar to static http servers, Vite has the concept of a "root directory" which your files are served from. You will see it referenced as <root> throughout the rest of the docs. Absolute URLs in your source code will be resolved using the project root as base, so you can write code as if you are working with a normal static file server (except way more powerful!). Vite is also capable of handling dependencies that resolve to out-of-root file system locations, which makes it usable even in a monorepo-based setup.
```

Vite also supports multi-page apps with multiple .html entry points.

Specifying Alternative Root
Running vite starts the dev server using the current working directory as root. You can specify an alternative root with vite serve some/sub/dir.

Command Line Interface
In a project where Vite is installed, you can use the vite binary in your npm scripts, or run it directly with npx vite. Here are the default npm scripts in a scaffolded Vite project:

```json
{
  "scripts": {
    "dev": "vite", // start dev server, aliases: `vite dev`, `vite serve`
    "build": "vite build", // build for production
    "preview": "vite preview" // locally preview production build
  }
}
```

You can specify additional CLI options like --port or --https. For a full list of CLI options, run npx vite --help in your project.

Learn more about the Command Line Interface

Sabin Adams

End-to-end type safety is implemented by ensuring the types across your entire application's stack are kept in sync.

PART 3
GraphQL API
PART 4
Codegen & Deployment

Technologies you will use
Prerequisites
Assumed knowledge
Development environment
Start a React application with Vite
Clean up the template
Set up TailwindCSS
Define and mock your data
Display a list of users
Display each user's messages
Summary & What's next

Implementing end-to-end type safety using React, GraphQL, Prisma, and some other helpful tools that tie those three together.

add a GraphQL API with a database that your application can consume to render its data dynamically.

Prisma as the Object-Relational Mapper (ORM)
PostgreSQL as the database
Railway to host your database
TypeScript as the programming language
GraphQL Yoga as the GraphQL server
Pothos as the code-first GraphQL schema builder
Vite to manage and scaffold your frontend project
React as the frontend JavaScript library
GraphQL Codegen to generate types for the frontend based on the GraphQL schema
TailwindCSS for styling the application
Render to deploy your API and React Application

While this series will attempt to cover everything in detail from a beginner's standpoint

Define which files in your project TailwindCSS should be aware of when scanning through your code and deciding which of its classes and utilities you are using

In order to ensure your application is type-safe, you will need to create a set of TypeScript types that define your two data models: users and messages.

In the next sections of this series, you will replace these manually written types with automatically generated ones that contain up-to-date representations of your API's exposed data model.

uses the Props type you wrote to describe the function arguments, pulls out the message and index values using destructuring, renders the message in a styled container, and finally exports the component:

`trunk` indicates whether or not the message it links to is the first in the list.

to build a fully type-safe application
