---
sidebar_position: 14
---

# x

## x

set up resolvers to pull live data from a REST data source.

query for a single track using GraphQL arguments

update our resolvers and data sources accordingly

send query using GraphQL variables

add page navigation

In the directory of your choice with your preferred terminal, clone the app's starter repository:

```bash
git clone https://github.com/apollographql/odyssey-lift-off-part3
```

In a terminal window, navigate to the repo's server directory

In a new terminal window, navigate to the repo's client directory and run the following to install dependencies and start the app:

Ready to have fun? Let's get started!

## Updating the schema

Putting our business glasses on, it looks reasonable to assume that a module should be a standalone type:

A single track might include any number of modules, and **one module might be part of multiple tracks**. So, we'll **create a separate Module type**.

Given this schema field: missions: [Mission!], which of the following statement is true:

## update our schema to retrieve a specific track, using arguments.

## Querying for a specific track

but we still need a way to query for a specific track by its ID

add a new entry point to our schema

"return a single Track"
track: Track

![the syntax breakdown of using GraphQL arguments](https://res.cloudinary.com/apollographql/image/upload/e_sharpen:50,c_scale,q_90,w_1440,fl_progressive/v1623354512/odyssey/lift-off-part3/args-syntax_t0wseq.jpg)

specify an unique track we're querying for by giving this field an **argument**

4 reasons to use arguments in a query

1. Provide a user-submitted search term

2. Transform a field's returned value

3. Retrieve a specific object

4. Filter a set of objects

To define an argument for a field in our schema, we add parentheses after the field name

Write the name of the argument followed by a colon, then the type of that argument, like String or Int

If we have more than one argument, we can separate them with commas.

the syntax breakdown of using GraphQL arguments

## Retrieving our data

```json title="response from the track/:id endpoint giving it the id = c_0"
{
  "id": "c_0",
  "thumbnail": "https://res.cloudinary.com/dety84pbu/image/upload/v1598465568/nebula_cat_djkt9r.jpg",
  "topic": "Cat-stronomy",
  "authorId": "cat-1",
  "title": "Cat-stronomy, an introduction",
  "description": "Curious to learn what Cat-stronomy is all about? Explore the planetary and celestial alignments and how they have affected our space missions.",
  "numberOfViews": 0,
  "createdAt": "2018-09-10T07:13:53.020Z",
  "length": 2377,
  "modulesCount": 10,
  "modules": ["l_0", "l_1", "l_2", "l_3", "l_4", "l_5", "l_6", "l_7", "l_8", "l_9"]
}
```

```js title="server/src/datasources/track-api.js"
// add the following method to the TrackAPI class:
// create a new method to get a single track based on its ID
getTrack(trackId) {
  // make a call to the track/:id endpoint
  return this.get(`track/${trackId}`);
}
```

Now that our data source is retrieving the data, our resolver should be able to use it! In Lift-off II, we already worked out the connection between our resolvers and data sources inside the ApolloServer configuration options, so we should be good to add more resolvers as necessary.

In our Query object, we'll add a new function below tracksForHome. In our schema, we named the fieldtrack, so here it has to have the same name.

```js title="server/src/resolvers.js"
// add a new resolver after the tracksForHome resolver:
// called the track resolver
// get a single track by ID, for the track page
track: (_, {id}, {dataSources}) => {
  return dataSources.trackAPI.getTrack(id);
},
```

We've used the third argument context before, to access the dataSources key. This is where our trackAPI.getTrack method lives. This method expects the id of a track. We'll specify that value later as an argument when we build the query.

To access this id, we can use the second parameter in the resolver: args. args is an object that contains all GraphQL arguments that were provided for the field. We can destructure this object to access the id property, then pass that id into our getTrack method.

Finally, let's clean up our two other parameters. We can replace parent with an underscore since we won't be using it, and we can omit the last parameter info altogether; we won't use it either.

Write a resolver function for the spaceCat field to query a spaceCat by ID. Follow the conventions used above for the four resolver parameters. Use the dataSources object to access the spaceCatsAPI.getSpaceCat() method, which takes the id from args and returns the results.
123456

```js
const resolvers = {
  Query: {
    // write your resolver here
  }
}
```

We're done with our track resolver, but not quite finished with our resolver work yet. If you recall, the track data returned by our REST API has a modules property, but it only contains a list of module IDs. Next, we'll need to make sure we're getting the details of each module.
