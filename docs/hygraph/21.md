---
sidebar_position: 21
---

# Apollo Federation : A modular supergraph architecture

Apollo Federation is an architecture for creating modular graphs. Your graph is built in smaller pieces that all work together.

[FlyBy](https://odyssey-flyby.netlify.app) : Let's imagine we've been transported far into the future, where everyone can traverse the galaxy for fun and adventure. FlyBy's users can browse a list of all the locations fellow space travelers have visited.

## Structure of a supergraph

### One or more separated **subgraphs**

The graph's functionality is divided across smaller, modular graphs called **subgraphs**. --> Schema is split across **multiple schema files**

Each subgraph is a **standalone GraphQL server** with its own schema file, data sources and resolvers. A subgraph schema should contain the types and fields it is responsible for resolving / populating.

How do we connect the fields of a single object when they're resolved by multiple subgraphs? (Lessons 9-14)

In production environment, each server will be managed on its own repository.

```bash title="Official repos from apollographql.com"
git clone https://github.com/apollographql/odyssey-voyage-I

# each server runs on a different port --> can be run at the same time
# 4000 : router
# 4001 : subgraph-locations
# 4002 : subgraph-reviews

# navigate to subgraph-locations
yarn add @apollo/subgraph

# navigate to subgraph-reviews
yarn add @apollo/subgraph
```

### A router (single endpoint)

The router splits incoming GraphQL operations into **smaller operations**, with the help of **supergraph schema**. Each split operation is resolved by a single subgraph.

Supergraph schema is composed of all the fields and types from each subgraph schema. Like a map, it helps the router determine which subgraph can resolve a field in an operation.

A very helpful illustration by [apollographql.com](https://www.apollographql.com/tutorials/voyage-part1/intro-to-federation)

![The journey of a GraphQL operation in a supergraph with the router and subgraphs](https://res.cloudinary.com/apollographql/image/upload/e_sharpen:50,c_scale,q_90,w_1440,fl_progressive/odyssey/federation-course1/F_01_01_IL_04_simple_architecture_exy5jk.png)

## Schema agreement

Collaborate with the frontend team to agree on the app's data requirements and implement a schema-first design. --> Decide how to split up these data needs across multiple subgraphs.

After agreeing on multiple subgraphs, frontend and backend teams can work in parallel. Backend teams can work on their own subgraphs independently, without impacting developers working on other subgraphs, and maintain on their own team.

**Separation of concerns principle** : Clear boundaries of responsibility for different parts of the graph.

Teams have the flexibility to choose the language, infrastructure, and policies that work best for them. Subgraphs can have different numbers of instances, security protocols or caching stragtegies.

## `locations.graphql` : the Homepage

A schema that defines the types and fields owned by the `locations` subgraph.

Contain a selection of the most recently submitted reviews across all locations

Contain a grid of all interplanetary locations.

- Contain overall rating and a snippet of its latest review.

```graphql title="subgraph-locations/locations.graphql"
extend schema @link(url: "https://specs.apollo.dev/federation/v2.0", import: ["@key"])

type Location @key(fields: "id") {
  id: ID!
  name: String!
  description: String!
  photo: String!
}

type Query {
  locations: [Location!]!
  location(id: ID!): Location
}
```

A very helpful illustration by [apollographql.com](https://www.apollographql.com/tutorials/voyage-part1/intro-to-federation)

![An annotated mock-up of the Homepage](https://res.cloudinary.com/apollographql/image/upload/e_sharpen:50,c_scale,q_90,w_1440,fl_progressive/odyssey/federation-course1/F_01_02_MK_21_xwbd1w.png)

```graphql title='Sample query for the Homepage'
query GetHomePageLocationsAndReviews {
  latestReviews {
    id
    comment
    rating
    location {
      name
    }
  }
  locations {
    id
    name
    overallRating
    photo
    reviewsForLocation {
      id
      comment
      rating
    }
  }
}
```

## `reviews.graphql` : the Location page

`overallRating` and `reviewsForLocation` have **more to do with reviews** than they do with locations, even though they happen to be fields on the Location object type.

```graphql title="subgraph-reviews/reviews.graphql"
extend schema @link(url: "https://specs.apollo.dev/federation/v2.0", import: ["@key"])

type Location @key(fields: "id") {
  id: ID!
  overallRating: Float
  "all submitted reviews of a specific location"
  reviewsForLocation: [Review]!
}

type Review {
  id: ID!
  comment: String
  rating: Int
  location: Location
}

input LocationReviewInput {
  comment: String!
  rating: Int!
  locationId: String!
}

type SubmitReviewResponse {
  code: Int!
  success: Boolean!
  message: String!
  locationReview: Review
}

"receive a $locationReview parameter of LocationReviewInput object type"
type Mutation {
  submitReview(locationReview: LocationReviewInput): SubmitReviewResponse
}

type Query {
  "3 latest reviews submitted for FlyBy's locations"
  latestReviews: [Review!]!
}
```

A very helpful illustration by [apollographql.com](https://www.apollographql.com/tutorials/voyage-part1/intro-to-federation)

![An annotated mock-up of the Location page](https://res.cloudinary.com/apollographql/image/upload/e_sharpen:50,c_scale,q_90,w_1440,fl_progressive/odyssey/federation-course1/F_01_02_MK_22_sfwd1g.jpg)

```graphql title='Sample query for the Location page'
query GetLocationDetails($locationId: ID!) {
  location(id: $locationId) {
    id
    name
    description
    photo
    overallRating
    reviewsForLocation {
      id
      comment
      rating
    }
  }
}
```

```graphql title='Sample mutation of submitting a review'
mutation SubmitReview($locationReview: LocationReviewInput) {
  submitReview(locationReview: $locationReview) {
    code
    success
    message
    locationReview {
      id
      comment
      rating
    }
  }
}
```

```
query GetAllLocations {
  locations {
    id
    name
    description
    photo
  }
}

query GetLatestReviews {
  latestReviews {
    id
    comment
    rating
  }
}
```

To make an ApolloServer instance a subgraph, we install a package called **@apollo/subgraph**. From that package, we use a function called **buildSubgraphSchema**, which accepts an object containing **typeDefs** and **resolvers**, and returns a federation-ready **subgraph schema**. We add this to the ApolloServer configuration object using the **schema** property.

## wording

intergalactic travels
dip our toes into the world of Federation
put concepts into practice
For a smoother learning experience
don't need to know a thing about how the graph is built under the hood.
locations presented by the Interplanetary Space Tourism department
See how things fit together with the frontend (Lesson 14)
easier to scale

@apollo/subgraph

schema agreement checklist

```graphql title="to test subgraph-locations server"
query GetAllLocations {
  locations {
    id
    name
    description
    photo
  }
}
```

```graphql title="to test subgraph-reviews server"
query GetLatestReviews {
  latestReviews {
    id
    comment
    rating
  }
}
```

The buildSubgraphSchema function takes an object containing typeDefs and resolvers and returns a federation-ready subgraph schema. This schema includes a number of federation directives and types that enable our subgraph to take full advantage of the power of federation. More on that in a bit!

---

# How a supergraph gets made from start to finish

Supergraph enables the router to resolve requests by routing queries to the underlying subgraphs.

## The managed federation workflow

Updates to your supergraph schema are handled by Apollo Studio and the schema registry, all with zero downtime for your router

### Step 1 : Backend developers independently design and build their subgraphs.

Decide how to distribute types and fields across multiple subgraphs.

Build out their subgraph servers, complete with schemas, resolvers, and data sources.

### Step 2 : Someone creates a new supergraph in Apollo Studio where the subgraphs can be registered

### Step 3 : Publish each subgraph's schema to the Apollo schema registry

Backend developers publish their subgraph schemas to the Apollo schema registry with Rover.

The schema registry is an Apollo-hosted version control system, which enables us to track changes to our schemas over time.

### Step 4 : Composing the supergraph schema

When the schema registry gets a new or updated version of a subgraph schema, it starts a process called composition. The schema registry attempts to combine all of the schemas from the registered subgraphs into a single supergraph schema.

If composition succeeds and there are no validation errors, the schema registry produces a supergraph schema. The schema registry automatically sends the supergraph schema to an internal service within Studio called Apollo Uplink. Uplink is a server that stores the latest supergraph schema for each graph.

### Step 5: The router polls Uplink for the latest supergraph schema

The router automatically polls Uplink periodically to see if there's a new version of the supergraph schema.

Most of the time, the router sees that the supergraph schema stored in Uplink is the same version as the one it's already using. In this case, nothing changes.

But if the router sees that Uplink contains a new version of the supergraph schema, the router automatically updates to use the new version - with no need to restart the server, and no downtime.

Now, any clients that communicate with the router will be able to reference and query the updated schema.

A very helpful illustration by [apollographql.com](https://www.apollographql.com/tutorials/voyage-part1/intro-to-federation)

![the full managed federation workflow](https://res.cloudinary.com/apollographql/image/upload/e_sharpen:50,c_scale,q_90,w_1440,fl_progressive/odyssey/federation-course1/federation_1_journey_xuk3pt.png)

Every supergraph includes one or more **subgraphs**, each of which has its own schema. With **managed federation**, each of these schemas is published to the Apollo schema registry. Whenever a subgraph schema is published, the schema registry triggers a process called **composition**. If successful, this process results in the creation of a **supergraph schema**, which is then fetched by the supergraph's **router** via periodic polling.

The schema registry automatically composes the subgraph schemas together into a supergraph schema. and makes it available via Apollo Uplink.

The router automatically polls Uplink for any new versions of the supergraph schema.

After creating or updating a subgraph schema, developers use the Rover CLI to publish the subgraph schema to the Apollo schema registry.

The Apollo schema registry composes the subgraph schemas into a supergraph schema, which the router uses to resolve incoming client requests.

With managed federation, schema updates to the router are managed by Apollo Studio and happen with zero downtime.

save two environment variables from Apollo Studio

APOLLO_KEY : An API key for authenticating Rover. It starts with something like service:your-graph-name.

APOLLO_GRAPH_REF : The graph reference (or graph ref) for our supergraph, which we'll use to tell
Rover where to publish our subgraphs.

A graph ref starts with the graph's ID, followed by an @ symbol, followed by the graph variant.

"rover subgraph publish" part of the command

```env title="router/.env"
APOLLO_KEY=your-graphs-apollo-key
APOLLO_GRAPH_REF=your-graph-name@current
```

.gitignore

```bash
# install Rover
curl -sSL https://rover.apollo.dev/nix/latest | sh
curl -sSL https://rover.apollo.dev/nix/latest | sh
downloading rover from https://github.com/apollographql/rover/releases/download/v0.10.0/rover-v0.10.0-x86_64-apple-darwin.tar.gz
writing binary to /Users/isaac/.rover/bin/rover
rover was successfully installed. Great!

To get started you need Rover's bin directory (/Users/isaac/.rover/bin) in your PATH environment variable. Next time you log in this will be done automatically.

To configure your current shell, you can run:
exec /bin/zsh -l
If you would like to disable Rover's anonymized usage collection, you can set APOLLO_TELEMETRY_DISABLED=1
You can check out our documentation at https://go.apollo.dev/r/docs.

#
APOLLO_KEY=service:odyssey-voyage-I-prsdol:jlMV2cgp1mQguR3RzQ4gNw \
  rover subgraph publish odyssey-voyage-I-prsdol@current \
  --schema ./products-schema.graphql \
  --name your-subgraph-name \
  --routing-url http://products.prod.svc.cluster.local:4001/graphql

# authenticate with APOLLO_KEY using Rover
rover config auth
```

```bash
APOLLO_KEY=<APOLLO_KEY> \
  rover subgraph publish <APOLLO_GRAPH_REF> \
  --name <SUBGRAPH NAME>
  --schema ./products-schema.graphql \
  --routing-url http://products.prod.svc.cluster.local:4001/graphql

rover subgraph publish odyssey-voyage-I-prsdol@current \
  --name locations \
  --schema ./subgraph-locations/locations.graphql \
  --routing-url http://localhost:4001

❯ rover subgraph publish odyssey-voyage-I-prsdol@current \
  --name locations \
  --schema ./subgraph-locations/locations.graphql \
  --routing-url http://localhost:4001
Publishing SDL to odyssey-voyage-I-prsdol@current (subgraph: locations) using credentials from the default profile.
A new subgraph called 'locations' was created in 'odyssey-voyage-I-prsdol@current'
The supergraph schema for 'odyssey-voyage-I-prsdol@current' was updated, composed from the updated 'locations' subgraph

❯ rover subgraph publish odyssey-voyage-I-prsdol@current \
  --name reviews \
  --schema ./subgraph-reviews/reviews.graphql \
  --routing-url http://localhost:4002
Publishing SDL to odyssey-voyage-I-prsdol@current (subgraph: reviews) using credentials from the default profile.
A new subgraph called 'reviews' was created in 'odyssey-voyage-I-prsdol@current'
The supergraph schema for 'odyssey-voyage-I-prsdol@current' was updated, composed from the updated 'reviews' subgraph

Monitor your schema delivery progression on studio: https://studio.apollographql.com/graph/odyssey-voyage-I-prsdol/launches/66ba1e52-02df-439b-90d6-179aa4a8fd6a?variant=current
```

register our subgraphs to the schema registry, and Apollo Studio automatically composed our supergraph schema for us!

Click on the SDL tab at the top of the Schema page. Here we can see details about our published subgraphs, along with two additional schemas.

API schema

- The GraphQL API that gets exposed to your clients

- Cleanly and logically represents the combination of your subgraph schemas.

Supergraph schema

- Used by the router like a map, to define how incoming GraphQL operations can be divided up among the underlying subgraphs

- Provide a complete picture for the router to query for information about locations, reviews, or any combination of the two

- Studio will automatically recompose this supergraph schema anytime we push a change to either one of our subgraphs.

- Consolidate all the types and fields across our published subgraphs. It also includes extra directives to help the router determine which subgraphs can resolve each field.

how the supergraph schema identifies the types and fields that belong to each one of our subgraphs.

the fields we added to the Query type in both subgraphs have been consolidated in one place. Each field is annotated with a special @join_field directive that references the name of its originating subgraph.

```graphql title="Supergraph schema"
type Query @join__type(graph: LOCATIONS) @join__type(graph: REVIEWS) {
  locations: [Location!]! @join__field(graph: LOCATIONS)
  location(id: ID!): Location @join__field(graph: LOCATIONS)

  """
  The three latest reviews submitted for FlyBy's locations
  """
  latestReviews: [Review!]! @join__field(graph: REVIEWS)
}
```

how the router uses the supergraph schema to resolve incoming GraphQL operations and bundle data from multiple subgraphs into one clean response.

## Entire journey of a GraphQL operation through the supergraph

Trace the journey of a client request through the supergraph

Describe how the router creates query plans to resolve GraphQL operations across multiple subgraphs

The journey of a GraphQL operation through the supergraph
Let's start at the beginning: from the client request.

### Step 1 : The client sends a GraphQL operation to the router

The client has no clue which fields belong to which subgraphs—or even that there are subgraphs at all.

### Step 2 : Building a query plan

The router looks at the fields in the operation and uses the supergraph schema to figure out which subgraphs are responsible for resolving each field.

The router builds a query plan, a list of smaller GraphQL operations to execute on the subgraphs. The query plan also specifies the order in which the subgraph operations need to run.

### Step 3 : Executing the query plan

The router carries out the query plan by sending the smaller GraphQL operations to each of the subgraphs it needs data from.

The subgraphs resolve the operations the same way as any other GraphQL server: they use their resolvers and data sources to retrieve and populate the requested data.

### Step 4 : The subgraph responses

The subgraphs send back the requested data to the router, and then the router combines all those responses into a single JSON object.

### Step 5 : Sending data back to the client

The router sends the final JSON object back to the client.

A very helpful illustration by [apollographql.com](https://www.apollographql.com/tutorials/voyage-part1/intro-to-federation)

![Entire journey of a GraphQL operation through the supergraph](https://res.cloudinary.com/apollographql/image/upload/e_sharpen:50,c_scale,q_90,w_1440,fl_progressive/odyssey/federation-course1/federation_1_query_wpi_wad3yi.png)

The router uses the supergraph schema to create a query plan for the incoming GraphQL operation.

The query plan is a list of smaller operations the router can execute on different subgraphs to fully resolve the incoming operation.

The router carries out the query plan by executing the list of operations on the appropriate subgraphs.

The router combines all the responses from the subgraphs into a single JSON object, which it sends back to the client.

Configure the router to poll Apollo Uplink for our supergraph schema, and we'll finally begin querying our supergraph!

# Set up the Apollo Router locally

So far, FlyBy's subgraphs are running and their schemas have been published, but we still need one piece to tie everything together: the router.

Connect our router to Apollo Studio
Send our first query to our supergraph
✏️ Downloading the router
The Apollo Router is a high-performance graph router built in Rust. It's available as an executable binary that you can add to your project in a few steps:

```bash
# navigate to the router directory in the FlyBy project
❯ cd router

# download & install the router
❯ curl -sSL https://router.apollo.dev/download/nix/latest | sh

Downloading router from https://github.com/apollographql/router/releases/download/v1.7.0/router-v1.7.0-x86_64-apple-darwin.tar.gz ...
Moving /var/folders/37/jzgl0cr516j9vb9xqyw1_c_r0000gn/T/tmp.7jFLFeie/router to ./router ...

You can now run the Apollo Router using './router'

# start up the router locally and tells the router which supergraph to connect to
APOLLO_KEY=<> APOLLO_GRAPH_REF=<> ./router

2022-12-24T01:11:31.531529Z  INFO Apollo Router v1.7.0 // (c) Apollo Graph, Inc. // Licensed as ELv2 (https://go.apollo.dev/elv2)
2022-12-24T01:11:31.531662Z  INFO Anonymous usage data is gathered to inform Apollo product development.  See https://go.apollo.dev/o/privacy for more info.
2022-12-24T01:11:32.237247Z  INFO Apollo Studio usage reporting is enabled. See https://go.apollo.dev/o/data for details
2022-12-24T01:11:33.477713Z  INFO healthcheck endpoint exposed at http://127.0.0.1:8088/health
2022-12-24T01:11:33.478434Z  INFO GraphQL endpoint exposed at http://127.0.0.1:4000/ 🚀
```

## Connect the router to Apollo Studio

The router ( GraphQL endpoint ) is locally running at http://127.0.0.1:4000

Step 1 : Click on the README tab in the sidebar.

Step 2 : Click the **Connection Settings** link at the top of the page.

Step 3 : Paste the router address we copied (http://127.0.0.1:4000) as the endpoint, then save.

Step 4 : Query the router from our own machines.

```
query GetLocationsAndLatestReviews {
  locations {
    id
    name
    description
    photo
  }
  latestReviews {
    id
    comment
    rating
  }
}
```

- Query Plan Preview panel with steps broken down in a diagram

Show plan as text, we'll see a more detailed breakdown of the query plan

What information does the Query Plan Preview in Apollo Studio include?

Key takeaways
The Apollo Router is an executable binary file that can be downloaded and run locally.
The Query Plan Preview inspects the GraphQL operation in the Explorer and outputs the query plan the router will execute to resolve the operation.
Up next
Congratulations, we now have a working supergraph! Our frontend team can get back all the data they need from a single GraphQL operation, and we've improved our development experience by modularizing the backend!

But there's still one problem we need to solve.

Remember those three fields we still haven't added to our schema? You remember! Here's that schema agreement again, to jog your memory:

The FlyBy schema diagram, updated to check off the fields we've added to the reviews and locations subgraphs so far
Even though our router can query each subgraph separately, we can't associate data between the two subgraphs yet.

Well, next up we'll learn about the feature that will make coordination between our subgraphs possible: entities.
