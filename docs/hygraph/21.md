---
sidebar_position: 21
---

# Apollo Federation

Apollo Federation is an architecture for creating modular graphs. Your graph is built in smaller pieces that all work together.

[FlyBy](https://odyssey-flyby.netlify.app) : Let's imagine we've been transported far into the future, where everyone can traverse the galaxy for fun and adventure. FlyBy's users can browse a list of all the locations fellow space travelers have visited.

## One or more **subgraphs**

The graph's functionality is divided across smaller, modular graphs called **subgraphs**. --> Schema is split across **multiple schema files**.

Each subgraph runs by a GraphQL server with its own schema file, data sources and resolvers. A subgraph schema should contain the types and fields it is responsible for resolving / populating.

In a production environment, each server has it's own repository.

```bash title="Repos from apollographql.com"
git clone https://github.com/apollographql/odyssey-voyage-I

# 4000 : router
# 4001 : subgraph-locations
# 4002 : subgraph-reviews

# navigate to subgraph-locations/
yarn add @apollo/subgraph

# navigate to subgraph-reviews/
yarn add @apollo/subgraph
```

## The router (single endpoint)

The router splits incoming GraphQL operations into **smaller operations**, with the help of **supergraph schema**. Each split operation is resolved by a single underlying subgraph.

Supergraph schema, like a map / complete picture, is composed of all the fields and types from each subgraph schema. It contains extra directives to help the router determine which underlying subgraph can resolve a field in an operation.

A very helpful illustration by [apollographql.com](https://www.apollographql.com/tutorials/voyage-part1/intro-to-federation)

![The journey of a GraphQL operation in a supergraph with the router and subgraphs](https://res.cloudinary.com/apollographql/image/upload/e_sharpen:50,c_scale,q_90,w_1440,fl_progressive/odyssey/federation-course1/F_01_01_IL_04_simple_architecture_exy5jk.png)

## Federation workflow

### Step 1 : Collaborate with the frontend team to agree on the app's data requirements and implement a schema-first design.

Decide how to split up these data needs across multiple subgraphs. <-- Schema agreement

### Step 2 : Backend developers independently design and build their subgraphs.

After agreeing on multiple subgraphs, frontend and backend teams can work in parallel. Backend developers :

1. Decide how to distribute types and fields across multiple subgraphs.

2. Work on their own subgraphs independently <-- **Separation of concerns principle** : Clear boundaries of responsibility for different parts of the graph.

3. Have the flexibility to choose the language, infrastructure, and policies that work best for each subgraph. For example, subgraphs can have different numbers of instances, security protocols or caching stragtegies.

4. Build out their own subgraph servers, complete with schemas, data sources and resolvers.

### Step 3 : Someone **creates a new supergraph** in Apollo Studio.

### Step 4 : Backend developers **publish** their **subgraph schemas** to Apollo schema registry with Rover.

```bash title="publishing subgraph schemas"
# install Rover
curl -sSL https://rover.apollo.dev/nix/latest | sh

# /Users/isaac/.rover/bin will be automatically added to the PATH environment variable next time you log in
# https://go.apollo.dev/r/docs
# exec /bin/zsh -l
# you can set APOLLO_TELEMETRY_DISABLED=1

# authenticate with APOLLO_KEY : An API key for authentication
rover config auth

❯ rover subgraph publish odyssey-voyage-I-prsdol@current \
  --name locations \
  --schema ./subgraph-locations/locations.graphql \
  --routing-url http://localhost:4001

❯ rover subgraph publish odyssey-voyage-I-prsdol@current \
  --name reviews \
  --schema ./subgraph-reviews/reviews.graphql \
  --routing-url http://localhost:4002
```

```bash title="template"
APOLLO_KEY=<APOLLO_KEY> \
  rover subgraph publish <APOLLO_GRAPH_REF> \
  --name <SUBGRAPH NAME>
  --schema ./<SUBGRAPH NAME>.graphql \
  --routing-url http://products.prod.svc.cluster.local:4001/graphql
```

```env title="router/.env"
APOLLO_KEY=x
APOLLO_GRAPH_REF=x
```

### Step 5 : The schema registry attempts to **combine** all the schemas into **a single supergraph schema**. <-- **Composition**

If succeeds and no validation errors, the schema registry sends the supergraph schema to **Apollo Uplink** (an internal service).

Uplink is a server that stores the latest supergraph schema for each project.

Supergraph schema will be automatically recomposed when a change to either one of subgraphs is pushed.

The schema registry is a version control system. **Schemas changes can be tracked**.

### Step 6 : The **router** polls Uplink for the latest supergraph schema.

The router polls Uplink periodically for any new versions of the supergraph schema.

Clients will be able to reference and query from the latest supergraph schema.

A very helpful illustration by [apollographql.com](https://www.apollographql.com/tutorials/voyage-part1/intro-to-federation)

![The full federation workflow](https://res.cloudinary.com/apollographql/image/upload/e_sharpen:50,c_scale,q_90,w_1440,fl_progressive/odyssey/federation-course1/federation_1_journey_xuk3pt.png)

## The journey of a GraphQL operation through Apollo Federation

### Step 1 : A client sends a GraphQL operation to the router.

The client has no clue which fields belong to which subgraphs, or even that there are underlying subgraphs at all.

### Step 2 : The router builds a query plan.

The router looks at the fields in the operation and uses the **supergraph schema** to figure out which subgraphs are responsible for resolving each field.

The query plan is an ordered list of smaller GraphQL operations which will be sent across multiple appropriate subgraphs.

### Step 3 : The router executes the query plan.

Subgraphs resolve the operations. <-- Retrieve and populate the requested data.

### Step 4 : The router combines all the returned responses into a single JSON object.

### Step 5 : The router sends the final JSON object to the client.

A very helpful illustration by [apollographql.com](https://www.apollographql.com/tutorials/voyage-part1/intro-to-federation)

![Entire journey of a GraphQL operation through the supergraph](https://res.cloudinary.com/apollographql/image/upload/e_sharpen:50,c_scale,q_90,w_1440,fl_progressive/odyssey/federation-course1/federation_1_query_wpi_wad3yi.png)

the homepage contains a selection of the most recently submitted reviews.

### `locations.graphql`

A very helpful illustration by [apollographql.com](https://www.apollographql.com/tutorials/voyage-part1/intro-to-federation)

![An annotated mock-up of the Homepage](https://res.cloudinary.com/apollographql/image/upload/e_sharpen:50,c_scale,q_90,w_1440,fl_progressive/odyssey/federation-course1/F_01_02_MK_21_xwbd1w.png)

```graphql title='Sample query for the Homepage'
query GetHomePageLocationsAndReviews {
  latestReviews {
    id
    comment
    rating
    location {
      name
    }
  }
  locations {
    id
    name
    overallRating
    photo
    reviewsForLocation {
      id
      comment
      rating
    }
  }
}
```

## `reviews.graphql`

A very helpful illustration by [apollographql.com](https://www.apollographql.com/tutorials/voyage-part1/intro-to-federation)

![An annotated mock-up of the Location page](https://res.cloudinary.com/apollographql/image/upload/e_sharpen:50,c_scale,q_90,w_1440,fl_progressive/odyssey/federation-course1/F_01_02_MK_22_sfwd1g.jpg)

```graphql title='Sample query for the Location page'
query GetLocationDetails($locationId: ID!) {
  location(id: $locationId) {
    id
    name
    description
    photo
    overallRating
    reviewsForLocation {
      id
      comment
      rating
    }
  }
}
```

```graphql title='Sample mutation of submitting a review'
mutation SubmitReview($locationReview: LocationReviewInput) {
  submitReview(locationReview: $locationReview) {
    code
    success
    message
    locationReview {
      id
      comment
      rating
    }
  }
}
```

```
query GetAllLocations {
  locations {
    id
    name
    description
    photo
  }
}

query GetLatestReviews {
  latestReviews {
    id
    comment
    rating
  }
}
```

## `buildSubgraphSchema`

**@apollo/subgraph** contains a function called **buildSubgraphSchema**

- Accept an object containing **typeDefs** and **resolvers**

- Return a federation-ready **subgraph schema**

```graphql title="to test subgraph-locations server"
query GetAllLocations {
  locations {
    id
    name
    description
    photo
  }
}
```

```graphql title="to test subgraph-reviews server"
query GetLatestReviews {
  latestReviews {
    id
    comment
    rating
  }
}
```

The buildSubgraphSchema function takes an object containing typeDefs and resolvers and returns a federation-ready subgraph schema. This schema includes a number of federation directives and types that enable our subgraph to take full advantage of the power of federation. More on that in a bit!

---

A graph ref starts with the graph's ID, followed by an @ symbol, followed by the graph variant.

API schema

- The GraphQL API that gets exposed to your clients

- Cleanly and logically represents the combination of your subgraph schemas.

the fields we added to the Query type in both subgraphs have been consolidated in one place. Each field is annotated with a special @join_field directive that references the name of its originating subgraph.

```graphql title="Supergraph schema"
type Query @join__type(graph: LOCATIONS) @join__type(graph: REVIEWS) {
  locations: [Location!]! @join__field(graph: LOCATIONS)
  location(id: ID!): Location @join__field(graph: LOCATIONS)

  """
  The three latest reviews submitted for FlyBy's locations
  """
  latestReviews: [Review!]! @join__field(graph: REVIEWS)
}
```

how the router uses the supergraph schema to resolve incoming GraphQL operations and bundle data from multiple subgraphs into one clean response.

## Connect Apollo Router to Apollo Studio

The router ties everything together.

```bash
# navigate to router/ in the FlyBy project
❯ cd router

# download & install the router (an executable binary built with rush)
❯ curl -sSL https://router.apollo.dev/download/nix/latest | sh

# tell the router which supergraph to connect to
APOLLO_KEY=x APOLLO_GRAPH_REF=x ./router
```

```
query GetLocationsAndLatestReviews {
  locations {
    id
    name
    description
    photo
  }
  latestReviews {
    id
    comment
    rating
  }
}
```

Show plan as text, we'll see a more detailed breakdown of the query plan

What information does the Query Plan Preview in Apollo Studio include?

The Query Plan Preview inspects the GraphQL operation and outputs the query plan that the router will execute to resolve the operation. <-- Steps broken down in a diagram

## Entities : Associating / coordinating data between multiple subgraphs

```graphql title="locations.graphql"
extend schema @link(url: "https://specs.apollo.dev/federation/v2.0", import: ["@key"])

type Location @key(fields: "id") {
  id: ID!
  name: String!
  description: String!
  photo: String!
}

type Query {
  locations: [Location!]!
  location(id: ID!): Location
}
```

```graphql title="reviews.graphql"
extend schema @link(url: "https://specs.apollo.dev/federation/v2.0", import: ["@key"])

type Review {
  id: ID!
  comment: String
  rating: Int
  location: Location
}

type Location @key(fields: "id") {
  id: ID!
  overallRating: Float
  reviewsForLocation: [Review]!
}

type Mutation {
  submitReview(locationReview: LocationReviewInput): SubmitReviewResponse
}

type SubmitReviewResponse {
  code: Int!
  success: Boolean!
  message: String!
  "Newly created review"
  locationReview: Review
}

input LocationReviewInput {
  comment: String!
  rating: Int!
  locationId: String!
}

type Query {
  latestReviews: [Review!]!
}
```

`overallRating` and `reviewsForLocation` have **more to do with reviews** than they do with `locations`, even though they seem to be fields on the Location object type.

Review.location: This is a field on the Review type (which lives in the reviews subgraph), but the field has a return type of Location, which is defined in the locations subgraph.

An **entity** is an object that can resolve its fields across multiple subgraphs. <-- **fields are split across multiple subgraphs**.

The involved subgraphs can contribute fields to and resolve independently.

The subgraph that defines an entity can do one or both of the following:

1. Reference the entity

- The Review object type, with a location field that has a return value of Location type. <-- Reference the Location entity

2. Contribute fields to the entity

- The reviews subgraph contributes two review-specific fields to the Location entity. <-- `reviewsForLocation` and `overallRating`

- The Location entity, with fields divided between the locations and reviews subgraph.

- One subgraph adds new fields to an entity that are specific to that subgraph's concerns.

- The locations subgraph contributes these fields to the Location entity.

the Location entity will have fields for name, description, and photo, which will live in the locations subgraph.

To create an entity, we use the @key directive to specify which field(s) can uniquely identify an instance of that entity (e.g. a location with id "loc-1") within a subgraph. <-- Define a primary key

Primary keys are used to collect data across multiple subgraphs and associate with a single entity instance.

```graphql title="locations.graphql"
extend schema @link(url: "https://specs.apollo.dev/federation/v2.0", import: ["@key"])

type Location @key(fields: "id") {
  id: ID!
  name: String!
  description: String!
  photo: String!
}
```

2. Define a reference resolver function

contributes fields to an entity

The router uses reference resolvers to directly access the entity fields that each subgraph contributes.

Illustration of each subgraph contributing fields to an entity with an associated reference resolver.

\_\_resolveReference

Define each entity's reference resolver right alongside all the field resolvers for that type.

A reference resolver function has three arguments.

`reference`: The entity representation object that's passed in by the router. This tells the subgraph which instance of an entity is being requested. We'll cover what an entity representation is in the section below.

`context`: The object shared across all resolvers. This is the same as in normal resolvers.

`info`: Contains information about the operation's execution state, just like in a normal resolver.
We won't use this argument much.

![Illustration of an reference resolver function](https://res.cloudinary.com/apollographql/image/upload/e_sharpen:50,c_scale,q_90,w_1440,fl_progressive/odyssey/federation-course1/F_01_09_IL_rr-args_cmspgb.png)

each subgraph contributing fields to an entity with
an associated reference resolver.

An entity representation is an object that the router uses to represent a specific instance of an entity. A representation always includes the typename for that entity and the @key field for the specific instance.

The **typename field: This field exists on all GraphQL types automatically. It always returns the name of its containing type, as a string. For example, Location.**typename returns "Location".

The @key field: The key-value pair that a subgraph can use to identify the instance of an entity. For example, if we defined the Location entity using the "id" field as a primary key, then our entity representation would include an "id" property with a value like "loc-2".
An entity representation for a location might look like this:

Example location entity representation

```graphql title=""
{
  "__typename": "Location",
  "id": "loc-2"
}
```

think of an entity representation as a passport that the router uses to refer to a particular object between subgraphs.

The typename field is like a passport's country of origin. It says which entity the object belongs to. And the @key field is like a passport's ID number, uniquely identifying this instance of that entity.

The representation object is like a passport

We can use entities in two ways:

As a return type for a field (referencing an entity).

Defining fields for an entity from multiple subgraphs (contributing to an entity).

Any subgraph that contributes fields to an entity needs to define a reference resolver function for that entity. This \_\_resolveReference resolver is called whenever the router needs to access fields of the entity from within another subgraph.

An entity representation is an object that the router uses to represent a specific instance of an entity. It includes the entity's type and its key field(s).

## wording

interplanetary locations, intergalactic travels
dip our toes into the world of Federation
put concepts into practice
For a smoother learning experience
don't need to know a thing about how the graph is built under the hood.
locations presented by the Interplanetary Space Tourism department
See how things fit together with the frontend (Lesson 14)
easier to scale
