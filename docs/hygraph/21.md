---
sidebar_position: 21
---

# Apollo Federation

Apollo Federation is an architecture for creating modular graphs. Your graph is built in smaller pieces that all work together.

[FlyBy](https://odyssey-flyby.netlify.app) : Let's imagine we've been transported far into the future, where everyone can traverse the galaxy for fun and adventure. FlyBy's users can browse a list of all the locations fellow space travelers have visited.

## One or more **subgraphs**

The graph's functionality is divided across smaller, modular graphs called **subgraphs**. --> Schema is split across **multiple schema files**.

Each subgraph runs by a GraphQL server with its own schema file, data sources and resolvers. A subgraph schema should contain the types and fields it is responsible for resolving / populating.

In a production environment, each server has it's own repository.

```bash title="Repos from apollographql.com"
git clone https://github.com/apollographql/odyssey-voyage-I

# 4000 : router
# 4001 : subgraph-locations
# 4002 : subgraph-reviews

# navigate to subgraph-locations/
yarn add @apollo/subgraph

# navigate to subgraph-reviews/
yarn add @apollo/subgraph
```

## The router

The router (single endpoint) splits incoming GraphQL operations into **smaller operations**, with the help of **supergraph schema**. Each split operation is resolved by a single underlying subgraph.

Supergraph schema, like a map / complete picture, is composed of all the fields and types from each subgraph schema. It contains extra directives to help the router determine which underlying subgraph can resolve a field in an operation.

A very helpful illustration by [apollographql.com](https://www.apollographql.com/tutorials/voyage-part1/intro-to-federation)

![The journey of a GraphQL operation in a supergraph with the router and subgraphs](https://res.cloudinary.com/apollographql/image/upload/e_sharpen:50,c_scale,q_90,w_1440,fl_progressive/odyssey/federation-course1/F_01_01_IL_04_simple_architecture_exy5jk.png)

## Federation workflow

### 1: Agree on **data requirements**

Collaborate with the frontend team to agree on the app's data requirements and implement a schema-first design.

Decide how to split up these data needs across multiple subgraphs. <-- Schema agreement

### 2: Build subgraphs

Frontend and backend teams can work in parallel. Backend developers :

1. Decide how to distribute types and fields across multiple subgraphs.

2. Work on their own subgraphs independently <-- **Separation of concerns principle** : Clear boundaries of responsibility for different parts of the graph.

3. Have the flexibility to choose the language, infrastructure, and policies that work best for each subgraph. Subgraphs can have different numbers of instances, security protocols or caching stragtegies.

4. Build out their own subgraph servers, complete with schemas, data sources and resolvers.

### 3: Create a **supergraph**

Someone **creates a new supergraph** in Apollo Studio.

### 4: Publish **subgraph schemas**

Backend developers **publish** their **subgraph schemas** to Apollo schema registry with Rover.

```bash title="publishing subgraph schemas"
# install Rover
curl -sSL https://rover.apollo.dev/nix/latest | sh

# /Users/isaac/.rover/bin will be automatically added to the PATH environment variable next time you log in
# https://go.apollo.dev/r/docs
# exec /bin/zsh -l
# you can set APOLLO_TELEMETRY_DISABLED=1

# authenticate with APOLLO_KEY : An API key for authentication
rover config auth

❯ rover subgraph publish odyssey-voyage-I-prsdol@current \
  --name locations \
  --schema ./subgraph-locations/locations.graphql \
  --routing-url http://localhost:4001

❯ rover subgraph publish odyssey-voyage-I-prsdol@current \
  --name reviews \
  --schema ./subgraph-reviews/reviews.graphql \
  --routing-url http://localhost:4002
```

```bash title="template"
APOLLO_KEY=<APOLLO_KEY> \
  rover subgraph publish <APOLLO_GRAPH_REF> \
  --name <SUBGRAPH NAME>
  --schema ./<SUBGRAPH NAME>.graphql \
  --routing-url http://products.prod.svc.cluster.local:4001/graphql
```

```env title="router/.env"
APOLLO_KEY=x
APOLLO_GRAPH_REF=x
```

### 5: Composition

The schema registry attempts to **combine** all the schemas into **a single supergraph schema**. <-- **Composition**

If succeeds and no validation errors, the schema registry sends the supergraph schema to **Apollo Uplink** (an internal service).

Uplink is a server that stores the latest supergraph schema for each project.

Supergraph schema will be automatically recomposed when a change to either one of subgraphs is pushed.

The schema registry is a version control system. **Schemas changes can be tracked**.

### 6: Uplink

The **router** periodically polls Uplink for any new versions of the supergraph schema.

Clients will be able to reference and query from the latest supergraph schema.

A very helpful illustration by [apollographql.com](https://www.apollographql.com/tutorials/voyage-part1/intro-to-federation)

![The full federation workflow](https://res.cloudinary.com/apollographql/image/upload/e_sharpen:50,c_scale,q_90,w_1440,fl_progressive/odyssey/federation-course1/federation_1_journey_xuk3pt.png)

## Journey of a GraphQL operation

### 1: Initial operation

A client sends a GraphQL operation to the router.

The client has no clue which fields belong to which subgraphs, or even that there are underlying subgraphs at all.

### 2: A query plan

The router builds a query plan, with the help of the **supergraph schema**. It starts from the top-level field of the incoming query.

It figure out which subgraphs are responsible for resolving each field. The query plan is an ordered list.

### 3: Execute the query plan

The router executes the query plan.

Subgraphs resolve the operations. <-- Retrieve and populate the requested data.

### 4: Form a single JSON object

The router combines all the data it received from subgraphs into a single JSON object.

### 5: Return the JSON object

The router sends the final JSON object to the client.

A very helpful illustration by [apollographql.com](https://www.apollographql.com/tutorials/voyage-part1/intro-to-federation)

![Entire journey of a GraphQL operation through the supergraph](https://res.cloudinary.com/apollographql/image/upload/e_sharpen:50,c_scale,q_90,w_1440,fl_progressive/odyssey/federation-course1/federation_1_query_wpi_wad3yi.png)

## `locations.graphql`

A very helpful illustration by [apollographql.com](https://www.apollographql.com/tutorials/voyage-part1/intro-to-federation)

![An annotated mock-up of the Homepage](https://res.cloudinary.com/apollographql/image/upload/e_sharpen:50,c_scale,q_90,w_1440,fl_progressive/odyssey/federation-course1/F_01_02_MK_21_xwbd1w.png)

```graphql title='Sample query for the Homepage'
query GetHomePageLocationsAndReviews {
  latestReviews {
    id
    comment
    rating
    location {
      name
    }
  }
  locations {
    id
    name
    overallRating
    photo
    reviewsForLocation {
      id
      comment
      rating
    }
  }
}
```

## `reviews.graphql`

A very helpful illustration by [apollographql.com](https://www.apollographql.com/tutorials/voyage-part1/intro-to-federation)

![An annotated mock-up of the Location page](https://res.cloudinary.com/apollographql/image/upload/e_sharpen:50,c_scale,q_90,w_1440,fl_progressive/odyssey/federation-course1/F_01_02_MK_22_sfwd1g.jpg)

```graphql title='Sample query for the Location page'
query GetLocationDetails($locationId: ID!) {
  location(id: $locationId) {
    id
    name
    description
    photo
    overallRating
    reviewsForLocation {
      id
      comment
      rating
    }
  }
}
```

```graphql title='Sample mutation of submitting a review'
mutation SubmitReview($locationReview: LocationReviewInput) {
  submitReview(locationReview: $locationReview) {
    code
    success
    message
    locationReview {
      id
      comment
      rating
    }
  }
}
```

```
query GetAllLocations {
  locations {
    id
    name
    description
    photo
  }
}

query GetLatestReviews {
  latestReviews {
    id
    comment
    rating
  }
}
```

## Entities

Associate / coordinate data between multiple subgraphs.

```graphql title="locations.graphql"
extend schema @link(url: "https://specs.apollo.dev/federation/v2.0", import: ["@key"])

type Location @key(fields: "id") {
  id: ID!
  name: String!
  description: String!
  photo: String!
}

type Query {
  locations: [Location!]!
  location(id: ID!): Location
}
```

```graphql title="reviews.graphql"
extend schema @link(url: "https://specs.apollo.dev/federation/v2.0", import: ["@key"])

type Review {
  id: ID!
  comment: String
  rating: Int
  location: Location
}

type Location @key(fields: "id") {
  id: ID!
  overallRating: Float
  reviewsForLocation: [Review]!
}

type Mutation {
  submitReview(locationReview: LocationReviewInput): SubmitReviewResponse
}

type SubmitReviewResponse {
  code: Int!
  success: Boolean!
  message: String!
  "Newly created review"
  locationReview: Review
}

input LocationReviewInput {
  comment: String!
  rating: Int!
  locationId: String!
}

type Query {
  latestReviews: [Review!]!
}
```

An **entity** is a special **object type** that resolves its **fields across multiple subgraphs**.

`name`, `description` and `photo` of **Location entity** live in the **locations subgraph**.

`overallRating` and `reviewsForLocation` of **Location entity** live in the **reviews subgraph**.

`Review.location` has a return type of Location. <-- Referencing an entity.

The involved subgraphs can contribute fields to and resolve independently.

An entity's primary key is used to identify an unique instance of that entity within a **subgraph**. Data can be collected across multiple subgraphs with the help of primary key. An entity can have **more than one** primary key.

```graphql title="A book can be uniquely identified by its ISBN"
type Book @key(fields: "isbn") {
  title: String!
  authors: [String!]
  isbn: String!
  pages: Int
  publicationYear: Int
}
```

An **entity representation** is an object that the router uses to refer to a particular object between subgraphs. It always includes the entity's type and its **@key** field to represent a specific instance of an entity.

```graphql title="An entity representation for a location"
{
  "__typename": "Location",
  "id": "loc-2"
}
```

A very helpful illustration by [apollographql.com](https://www.apollographql.com/tutorials/voyage-part1/intro-to-federation)

![Illustration of an entity representation as a passport](https://res.cloudinary.com/apollographql/image/upload/e_sharpen:50,c_scale,q_90,w_1440,fl_progressive/odyssey/federation-course1/F_01_09_105_kz9akz.png)

A **reference resolver function** is used to return all the entity fields that a subgraph contributes. `__resolveReference` has 3 arguments :

- `reference`: The entity representation object that's passed in by the router. This tells the subgraph which instance of an entity is being requested.

- `context`: The object shared across all resolvers. This is the same as in normal resolvers.

- `info`: Contains information about the operation's execution state, just like in a normal resolver.

A very helpful illustration by [apollographql.com](https://www.apollographql.com/tutorials/voyage-part1/intro-to-federation)

![Illustration of an reference resolver function](https://res.cloudinary.com/apollographql/image/upload/e_sharpen:50,c_scale,q_90,w_1440,fl_progressive/odyssey/federation-course1/F_01_09_IL_rr-args_cmspgb.png)

```graphql title="subgraph-reviews/reviews.graphql"
type Location @key(fields: "id", resolvable: false) {
  id: ID!
}
```

- A **stub** serves as a **basic representation** of a type that includes just enough information to work with that type in the subgraph. --> Given our reviews subgraph a stub of the Location entity.

- Inside the @key directive, add one more property called resolvable and set it to false.

- the reviews subgraph **doesn't define (as no need) a reference resolver** for this entity.

- The reviews subgraph doesn't contribute any other fields (besides the key field). The reviews subgraph is **not responsible for resolving any of the entity's non-@key fields**.

A very helpful illustration by [apollographql.com](https://www.apollographql.com/tutorials/voyage-part1/intro-to-federation)

![The router adds a query for the location name to the query plan](https://res.cloudinary.com/apollographql/image/upload/e_sharpen:50,c_scale,q_90,w_1440,fl_progressive/odyssey/federation-course1/F_01_11_IL_location_name_ho8vy2.png)

A very helpful illustration by [apollographql.com](https://www.apollographql.com/tutorials/voyage-part1/intro-to-federation)

![The router uses the entities field](https://res.cloudinary.com/apollographql/image/upload/e_sharpen:50,c_scale,q_90,w_1440,fl_progressive/v1643752110/odyssey/federation-course1/F_01_11_IL_60_kps963.png)

A very helpful illustration by [apollographql.com](https://www.apollographql.com/tutorials/voyage-part1/intro-to-federation)

![The locations subgraph looks at the __typename value of each reference object to determine which entity's reference resolver to use](https://res.cloudinary.com/apollographql/image/upload/e_sharpen:50,c_scale,q_90,w_1440,fl_progressive/v1643752110/odyssey/federation-course1/F_01_11_IL_61_zwdl2p.png)

## `buildSubgraphSchema`

**@apollo/subgraph** contains a function called **buildSubgraphSchema**

- Accept an object containing **typeDefs** and **resolvers**

- Return a federation-ready **subgraph schema**

```graphql title="to test subgraph-locations server"
query GetAllLocations {
  locations {
    id
    name
    description
    photo
  }
}
```

```graphql title="to test subgraph-reviews server"
query GetLatestReviews {
  latestReviews {
    id
    comment
    rating
  }
}
```

The buildSubgraphSchema function takes an object containing typeDefs and resolvers and returns a federation-ready subgraph schema. This schema includes a number of federation directives and types that enable our subgraph to take full advantage of the power of federation. More on that in a bit!

---

A graph ref starts with the graph's ID, followed by an @ symbol, followed by the graph variant.

API schema

- The GraphQL API that gets exposed to your clients

- Cleanly and logically represents the combination of your subgraph schemas.

the fields we added to the Query type in both subgraphs have been consolidated in one place. Each field is annotated with a special @join_field directive that references the name of its originating subgraph.

```graphql title="Supergraph schema"
type Query @join__type(graph: LOCATIONS) @join__type(graph: REVIEWS) {
  locations: [Location!]! @join__field(graph: LOCATIONS)
  location(id: ID!): Location @join__field(graph: LOCATIONS)

  """
  The three latest reviews submitted for FlyBy's locations
  """
  latestReviews: [Review!]! @join__field(graph: REVIEWS)
}
```

how the router uses the supergraph schema to resolve incoming GraphQL operations and bundle data from multiple subgraphs into one clean response.

## Connect Apollo Router to Apollo Studio

The router ties everything together.

```bash
# navigate to router/ in the FlyBy project
❯ cd router

# download & install the router (an executable binary built with rush)
❯ curl -sSL https://router.apollo.dev/download/nix/latest | sh

# tell the router which supergraph to connect to
APOLLO_KEY=x APOLLO_GRAPH_REF=x ./router
```

```
query GetLocationsAndLatestReviews {
  locations {
    id
    name
    description
    photo
  }
  latestReviews {
    id
    comment
    rating
  }
}
```

Show plan as text, we'll see a more detailed breakdown of the query plan

What information does the Query Plan Preview in Apollo Studio include?

The Query Plan Preview inspects the GraphQL operation and outputs the query plan that the router will execute to resolve the operation. <-- Steps broken down in a diagram

## Define the entity in locations subgraphs

there's a new field on the Query type called `_entities`. This is a special field that the router uses for coordinating data between subgraphs.

```bash
# in the top-level directory of our project
# omit the --routing-url option as we already set that value

rover subgraph publish <APOLLO_GRAPH_REF> \
--name locations \
--schema ./subgraph-locations/locations.graphql
```

```bash
rover subgraph publish <APOLLO_GRAPH_REF> \
  --name reviews \
  --schema ./subgraph-reviews/reviews.graphql
```

## how the router uses entities and entity representations to connect data from multiple subgraphs.

### How the router uses entities and the query plan to connect data from multiple subgraphs

### How entity representations and reference resolvers work together

```graphql title="Client requests for the latest reviews"
query GetLatestReviews {
  latestReviews {
    id
    comment
    rating
    location {
      name
    }
  }
}
```

## wording

interplanetary locations, intergalactic travels
dip our toes into the world of Federation
put concepts into practice
For a smoother learning experience
don't need to know a thing about how the graph is built under the hood.
locations presented by the Interplanetary Space Tourism department
See how things fit together with the frontend (Lesson 14)
easier to scale
