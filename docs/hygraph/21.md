---
sidebar_position: 21
---

# Apollo Federation : A modular supergraph architecture

Apollo Federation is an architecture for creating modular graphs. Your graph is built in smaller pieces that all work together.

[FlyBy](https://odyssey-flyby.netlify.app) : They can browse a list of all the locations fellow space travelers have visited. Let's imagine we've been transported far into the future, where everyone can traverse the galaxy for fun and adventure.

## wording

intergalactic travels
dip our toes into the world of Federation
put concepts into practice
For a smoother learning experience
don't need to know a thing about how the graph is built under the hood.
locations presented by the Interplanetary Space Tourism department
See how things fit together with the frontend (Lesson 14)
easier to scale

## Structure of a supergraph

- One or more separated **subgraphs**

  - The graph's functionality is divided across smaller, modular graphs called **subgraphs**. The schema is split across **multiple schema files**.

  - A subgraph is a **standalone GraphQL server** with its own schema file, data sources and resolvers. A subgraph schema should contain the types and fields it is responsible for resolving/populating.

  - How do we connect the fields of a single object when they're resolved by multiple subgraphs? (Lessons 9-14)

- A router (single endpoint)

  - The router splits incoming GraphQL operations into **smaller operations**, with the help of **supergraph schema**. Each of the split operations can be resolved by a single subgraph.

  - The supergraph schema is composed of all the fields and types from each subgraph schema. Like a map, it helps the router determine which subgraph can resolve each field in an operation.

A very helpful illustration by [apollographql.com](https://www.apollographql.com/tutorials/voyage-part1/intro-to-federation)

![The journey of a GraphQL operation in a supergraph with the router and subgraphs](https://res.cloudinary.com/apollographql/image/upload/e_sharpen:50,c_scale,q_90,w_1440,fl_progressive/odyssey/federation-course1/F_01_01_IL_04_simple_architecture_exy5jk.png)

## Coding setup

In production environment, each server will be managed on its own repository.

```bash title="Servers are split too as follows :"
git clone https://github.com/apollographql/odyssey-voyage-I

# each server runs on a different port --> can be run at the same time
# Port 4000 : router
# Port 4001 : subgraph-locations
# Port 4002 : subgraph-reviews
```

## Schema agreement

Collaborate with the frontend team to agree on the app's data requirements and implement a schema-first design. Decide how to split up these data needs across multiple subgraphs.

After agreeing on multiple subgraphs, frontend and backend teams can work in parallel.

Backend teams can work on their own subgraphs independently, without impacting developers working on other subgraphs, and maintain on their own team. Clearer boundaries of responsibility for different parts of the graph. <-- **Separation of concerns principle**

Teams have the flexibility to choose the language, infrastructure, and policies that work best for them.

Subgraphs can have different numbers of instances, security protocols or caching stragtegies.

## `locations.graphql` : the Homepage page

- A schema that defines the types and fields owned by the `locations` subgraph.

- Contain a selection of the most recently submitted reviews across all locations

- Contain a grid of interplanetary locations.

  - Overall rating and a snippet of its latest review.

```graphql title="subgraph-locations/locations.graphql"
extend schema @link(url: "https://specs.apollo.dev/federation/v2.0", import: ["@key"])

type Location @key(fields: "id") {
  id: ID!
  name: String!
  description: String!
  photo: String!
}

type Query {
  locations: [Location!]!
  location(id: ID!): Location
}
```

An illustration by [apollographql.com](https://www.apollographql.com/tutorials/voyage-part1/agreeing-on-a-schema)

![An annotated mock-up of the Homepage](https://res.cloudinary.com/apollographql/image/upload/e_sharpen:50,c_scale,q_90,w_1440,fl_progressive/odyssey/federation-course1/F_01_02_MK_21_xwbd1w.png)

```graphql title='Sample query for the Homepage'
query GetHomePageLocationsAndReviews {
  latestReviews {
    id
    comment
    rating
    location {
      name
    }
  }
  locations {
    id
    name
    overallRating
    photo
    reviewsForLocation {
      id
      comment
      rating
    }
  }
}
```

## `reviews.graphql` : the Location page

- `overallRating` and `reviewsForLocation` have **more to do with reviews** than they do with locations, even though they happen to be fields on the Location object type.

```graphql title="subgraph-reviews/reviews.graphql"
extend schema @link(url: "https://specs.apollo.dev/federation/v2.0", import: ["@key"])

type Review {
  id: ID!
  comment: String
  rating: Int
  location: Location
}

type Location @key(fields: "id") {
  id: ID!
  overallRating: Float
  "All submitted reviews about a specific location"
  reviewsForLocation: [Review]!
}

input LocationReviewInput {
  comment: String!
  rating: Int!
  locationId: String!
}

type SubmitReviewResponse {
  code: Int!
  success: Boolean!
  message: String!
  locationReview: Review
}

"receive a $locationReview parameter of the LocationReviewInput object type"
type Mutation {
  submitReview(locationReview: LocationReviewInput): SubmitReviewResponse
}

type Query {
  "The three latest reviews submitted for FlyBy's locations"
  latestReviews: [Review!]!
}
```

An illustration by [apollographql.com](https://www.apollographql.com/tutorials/voyage-part1/agreeing-on-a-schema)

![An annotated mock-up of the Location page](https://res.cloudinary.com/apollographql/image/upload/e_sharpen:50,c_scale,q_90,w_1440,fl_progressive/odyssey/federation-course1/F_01_02_MK_22_sfwd1g.jpg)

```graphql title='Sample query for the Location page'
query GetLocationDetails($locationId: ID!) {
  location(id: $locationId) {
    id
    name
    description
    photo
    overallRating
    reviewsForLocation {
      id
      comment
      rating
    }
  }
}
```

```graphql title='Sample mutation for submitting a new review'
mutation SubmitReview($locationReview: LocationReviewInput) {
  submitReview(locationReview: $locationReview) {
    code
    success
    message
    locationReview {
      id
      comment
      rating
    }
  }
}
```

## Separating our concerns

with each field highlighted to show whether it belongs to the locations or reviews subgraph.

Use the @apollo/subgraph package to convert the locations and reviews servers from normal GraphQL servers into subgraphs.

The FlyBy schema diagram, updated to check off the fields we've added to the reviews and locations subgraphs so far
Remember, we'll leave the three fields (Location.reviewsForLocation, Location.overallRating and Review.location) alone for now, but we'll get to them later on in the course!

✏️ Starting up the subgraph servers

Let's get these subgraph servers up and running. First, the locations subgraph.

```
query GetAllLocations {
  locations {
    id
    name
    description
    photo
  }
}
```

Now let's start up the reviews subgraph, which will follow similar steps!

```
query GetLatestReviews {
  latestReviews {
    id
    comment
    rating
  }
}
```

## Converting to subgraph servers

### Adding a Federation 2 definition to our subgraph schema files

### Updating our ApolloServer instances

```js title="subgraph-locations/locations.graphql"
extend schema
  @link(url: "https://specs.apollo.dev/federation/v2.0",
        import: ["@key"])
```

This lets us opt into the latest features of Apollo Federation version 2. It also lets us import the various directives we'd like to use within our schema file (like the @key directive, shown above). We'll cover the @key directive later, so don't worry too much about this syntax now.

```bash
# navigate to the subgraph-locations directory.
npm install @apollo/subgraph
```

```js title="subgraph-locations/index.js"
const { ApolloServer } = require("@apollo/server")
const { startStandaloneServer } = require("@apollo/server/standalone")
const { buildSubgraphSchema } = require("@apollo/subgraph")

const server = new ApolloServer({
  schema: buildSubgraphSchema({ typeDefs, resolvers })
})
```

Then we'll use the result to set a new ApolloServer configuration property called schema.

What's going on with the buildSubgraphSchema function?

The `buildSubgraphSchema` function takes an object containing typeDefs and resolvers and returns a federation-ready subgraph schema. This schema includes a number of federation directives and types that enable our subgraph to take full advantage of the power of federation. More on that in a bit!

When we save our changes to the server file, the locally running locations server should restart automatically. Now let's check that everything is working correctly! Let's go back to our browser window with Apollo Sandbox at http://localhost:4001.

Under the Query root type, we should see a new field, \_service. This is one of the federation-specific fields that buildSubgraphSchema adds to the subgraph. The router uses this field to access the SDL string for your subgraph schema. We won't use this field directly, but seeing it appear in the Explorer tells us that our subgraph is running correctly.

http://localhost:4001

The new \_service field appearing under the Query type
Now that we've set up the locations subgraph, it's time to repeat the process for the reviews subgraph! Just follow the same flow as before. You got this.

Hint: If you get stuck, you can always check the final directory for a hint.

Adding a Federation 2 definition to the top of our schema file lets us opt in to the latest features available in Apollo Federation 2.
To make an ApolloServer instance a federation-ready subgraph, use the buildSubgraphSchema function from the @apollo/subgraph package.
Up next
We've got our subgraphs up and running! But that's only the first piece of our supergraph architecture.

In the next lesson, we'll take a closer look at how we can use managed federation to pull all the pieces of our supergraph together.
