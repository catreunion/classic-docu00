---
sidebar_position: 2
---

# SQL Coding

## Entry Level

```sql
-- show all registered users
select * from auth.users;

-- create a table called todo_profiles
create table todo_profiles (
  id uuid references auth.users not null,
  username text unique,
  avatar_url text,
  joined_at timestamp with time zone default timezone('utc'::text, now()) not null,
  primary key (id),
  unique(username)
);

-- create a table called running2
create table running2 (
  id int generated by default as identity primary key,
  user_id uuid references auth.users not null,
  date text,
  description text,
  distance int,
  calories int,
  hours int,
  mins int,
  secs int,
  elevation int,
  avg_pace text,
  avg_hr int,
  max_hr int,
  img_url text
);

-- enable RLS on running2
alter table running2 enable row level security;

-- anyone can read `running2`
create policy "policy anyone_can_read"
  on running2 for select
  using ( auth.role() = 'anon' );

-- alternative
CREATE POLICY "policy anyone_can_read2"
  ON "public"."running2" AS PERMISSIVE FOR SELECT
  TO public USING ( auth.role() = 'anon' );

CREATE POLICY "users_fully_ctrl_their_own_data"
  ON "public"."running2" AS PERMISSIVE FOR ALL
  TO authenticated USING ( auth.uid() = user_id )

-- individuals can only access their own data --> data is protected
create policy "policy users_view_their_own_data"
  on todo_profiles for select
  using ( auth.uid() = id );

create policy "policy users_insert_their_own_data"
  on todo_profiles for insert
  with check ( auth.uid() = id );

create policy "policy users_update_their_own_data"
  on todo_profiles for update
  using ( auth.uid() = id );

create policy "policy users_all2"
  on running2 for all
  with check ( auth.uid() = user_id );

create table todos (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users not null,
  title text,
  content text,
  is_completed boolean default false,
  inserted_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table todos enable row level security;

create policy "policy users_create_todos"
  on todos for insert
  with check ( auth.uid() = user_id );

create policy "policy users_view_their_own_todos"
  on todos for select
  using ( auth.uid() = user_id );

create policy "policy users_update_their_own_todos"
  on todos for update
  using ( auth.uid() = user_id );

create policy "policy users_delete_their_own_todos"
  on todos for delete
  using ( auth.uid() = user_id );

-- another way to create a policy (1st example)
CREATE POLICY "policy anon_read_all"
  ON "public"."todos"
  AS PERMISSIVE FOR SELECT
  TO public
  USING ( auth.role() = 'anon' );
-- alternative : auth.role() = 'anon'
-- alternative : (role() = 'anon'::text)
-- alternative : (is_completed = true)

-- another way to create a policy (2nd example)
CREATE POLICY "policy users_do_all_their_data" ON "public"."running2"
  AS PERMISSIVE FOR ALL
  TO public
  USING ( auth.uid() = user_id )
-- alternative : auth.uid() = user_id
-- alternative : (uid() = user_id)

-- rename a policy
BEGIN;
  ALTER POLICY "anon_read_all" ON "public"."todos"
  RENAME TO "public_read_all";
COMMIT;
```

## User Management Starter

```sql
-- create a table called profiles
create table profiles (
  id uuid references auth.users not null primary key,
  updated_at timestamp with time zone,
  username text unique,
  full_name text,
  avatar_url text,
  website text,

  constraint username_length check (char_length(username) >= 3)
);

-- enable RLS on profiles
alter table profiles enable row level security;

create policy "policy anon_read_all"
  on profiles for select
  using ( true );

create policy "policy users_insert_their_own_data"
  on profiles for insert
  with check ( auth.uid() = id );

create policy "policy users_update_their_own_data"
  on profiles for update
  using ( auth.uid() = id );

-- automatically creates a profile entry when a new user signs up
create function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, full_name, avatar_url)
  values (new.id, new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'avatar_url');
  return new;
end;
$$ language plpgsql security definer;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- set up Storage
insert into storage.buckets (id, name)
  values ('avatars', 'avatars');

-- set up access controls for storage.
create policy "policy public_view_avatars"
  on storage.objects for select
  using ( bucket_id = 'avatars' );

create policy "policy public_upload_avatars"
  on storage.objects for insert
  with check ( bucket_id = 'avatars' );

create policy "policy public_update_avatars"
  on storage.objects for update
  with check ( bucket_id = 'avatars' );
```

## Advanced Level

```sql
create policy "Only Blizzard staff can update leaderboard"
  on my_scores
  for update using (
    right(auth.jwt() ->> 'email', 13) = '@blizzard.com'
  );

-- add data
insert into my_scores(name, score, user_id)
values
  ('Paul', 100, '5a4365e7-7c7d-4eaf-a8ee-9ec9432917ca'),
  ('Paul', 200, '5a4365e7-7c7d-4eaf-a8ee-9ec9432917ca'),
  ('Leto', 50,  '9ec94326-2e2d-2ea2-22e3-3a535a4365e7');

begin;
  drop publication if exists supabase_realtime;
  create publication supabase_realtime;
commit;

alter publication supabase_realtime add table todo_profiles;
```
