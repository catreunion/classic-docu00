---
sidebar_position: 1
---

# JSON Web Tokens (JWTs)

## from JSON to encoded string

A **JSON object** looks something like this :

```bash
{
  "id": "bb2bc9b1-f6a2-4921-a22a-988b21c064cd",
  "first_name": "Isaac",
  "last_name": "Li",
  "email": "isaacli@mac.com",
  "expires_at": 1670748631,
}
```

**JWTs** are JSON objects **encoded** using algorithm such as HS256, **signed** and sent around as a string.

Useful tools : [Encoder by Ant Wilson](https://replit.com/@awalias/jsonwebtokens#index.js), [JWT Debugger by jwt.io](https://jwt.io), [JWT Inspector by Tore Green](https://chrome.google.com/webstore/detail/jwt-inspector/jgjihoodklabhdoeffdjofnknfijolgk)

For example :

```bash
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJhdXRoZW50aWNhdGVkIiwiZXhwIjoxNjcwNzQ4NjMxLCJzdWIiOiJiYjJiYzliMS1mNmEyLTQ5MjEtYTIyYS05ODhiMjFjMDY0Y2QiLCJlbWFpbCI6ImlzYWFjbGlAbWFjLmNvbSIsInBob25lIjoiIiwiYXBwX21ldGFkYXRhIjp7InByb3ZpZGVyIjoiZW1haWwiLCJwcm92aWRlcnMiOlsiZW1haWwiXX0sInVzZXJfbWV0YWRhdGEiOnt9LCJyb2xlIjoiYXV0aGVudGljYXRlZCIsImFhbCI6ImFhbDEiLCJhbXIiOlt7Im1ldGhvZCI6InBhc3N3b3JkIiwidGltZXN0YW1wIjoxNjcwNzQ1MDMxfV0sInNlc3Npb25faWQiOiI3NDQzNGY2MS0xZGYxLTRjMTgtOGI5ZC1hOWMxN2NjYWE3OTAifQ.0mcYEjLpRNjKeN-o-olT2LZohCFHGik2_EXZaGONRnk
```

A JWT is composed of 3 segments.

- **algorithm** used in encoding

- original **payload**

- **signature** ( for token verification )

## Auth with Supabase and JWTs

1. When a user signs up, Supabase creates a new record in the `auth.users` table.

2. Supabase sends a confirmation email to the address provided, with a link to complete the registration.

```bash
// link on a confirm email
https://gyhtmyvqhywrkzulcrwa.supabase.co/auth/v1/verify?token=712871994756d7b26587e09906216c86c0a113b642f76504b5626a73&type=signup&redirect_to=http://localhost:3000/

// magic link on an email
https://gyhtmyvqhywrkzulcrwa.supabase.co/auth/v1/verify?token=6f91fa7888f47eca6b133d59036aa62ffc996eb3278a64797493df24&type=magiclink&redirect_to=http://localhost:3000
```

3. After clicing the link, **Supabase returns a JWT**, which contains the user's `id`, to the user for **authentication**.

For example :

```bash
http://localhost:3000/#access_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJhdXRoZW50aWNhdGVkIiwiZXhwIjoxNjE2NDI5MDY0LCJzdWIiOiI1YTQzNjVlNy03YzdkLTRlYWYtYThlZS05ZWM5NDMyOTE3Y2EiLCJlbWFpbCI6ImFudEBzdXBhYmFzZS5pbyIsImFwcF9tZXRhZGF0YSI6eyJwcm92aWRlciI6ImVtYWlsIn0sInVzZXJfbWV0YWRhdGEiOnt9LCJyb2xlIjoiYXV0aGVudGljYXRlZCJ9.4IFzn4eymqUNYYo2AHLxNRL8m08G93Qcg3_fblGqDjo&expires_in=3600&refresh_token=RuioJv2eLV05lgH5AlJwTw&token_type=bearer&type=signup
```

- `http://localhost:3000/`

  - the **base url**

  - need to be updated when running in production

- `#access_token=...` - the **JWT** issued to the user

- `&expires_in=3600` - valid for 60 minutes

- `&refresh_token=RuioJv2eLV05lgH5AlJwTw` - get a new JWT before expires

- `&token_type=bearer` - use Bearer header in requests

- `&type=signup` - JWT issued for ... signup / login / password reset / magic link

Supabase issues **new JWTs** when users login again or when existing JWTs expire.

JWT-based authentication is **decentralized** : Anyone with the `jwt_secret` can verify a token without needing access to a centralized database.

**Postgres** inspects the user's JWT to determine does he has the right to access certain content. <-- **Authorization**

Source : [Supabase docs](https://supabase.com/docs/learn/auth-deep-dive/auth-deep-dive-jwts), [Supabase YouTube](https://youtu.be/v3Exg5YpJvE),

Useful tools : [RESTED browser client](https://chrome.google.com/webstore/detail/rested/eelcnbccaccipfolokglfhhmapdchbfg/related)

## Keys

### Anon Key

Stands for **anonymous public** API key

For developers to send along **API requests** when interacting with Supabase

Safe to put into client-side code <-- okay if end users see it

### Service Role Key

Has super admin rights and **bypass RLS**

Should only ever be used on your own servers or environments

**Never share**; **never put into client-side code**

Keep it private

### "If my anon key can be found in client-side code, then can't someone use the anon key to access my data?"

Yes, and this is where **Row Level Security** and **policies** come in.

Policies **restrict table access** to authenticated users based on their JWT roles and email domains

Data is protected

# SQL Coding in Supabase

## Entry Level

```sql
-- show all registered users
select * from auth.users;

-- create a table called todo_profiles
create table todo_profiles (
  id uuid references auth.users not null,
  username text unique,
  avatar_url text,
  joined_at timestamp with time zone default timezone('utc'::text, now()) not null,
  primary key (id),
  unique(username)
);

-- create a table called running2
create table running2 (
  id int generated by default as identity primary key,
  user_id uuid references auth.users not null,
  date text,
  description text,
  distance int,
  calories int,
  hours int,
  mins int,
  secs int,
  elevation int,
  avg_pace text,
  avg_hr int,
  max_hr int,
  img_url text
);

-- enable RLS on running2
alter table running2 enable row level security;

-- anyone can read `running2`
create policy "policy anyone_can_read"
  on running2 for select
  using ( auth.role() = 'anon' );

-- alternative
CREATE POLICY "policy anyone_can_read2"
  ON "public"."running2" AS PERMISSIVE FOR SELECT
  TO public USING ( auth.role() = 'anon' );

CREATE POLICY "users_fully_ctrl_their_own_data"
  ON "public"."running2" AS PERMISSIVE FOR ALL
  TO authenticated USING ( auth.uid() = user_id )

-- individuals can only access their own data --> data is protected
create policy "policy users_view_their_own_data"
  on todo_profiles for select
  using ( auth.uid() = id );

create policy "policy users_insert_their_own_data"
  on todo_profiles for insert
  with check ( auth.uid() = id );

create policy "policy users_update_their_own_data"
  on todo_profiles for update
  using ( auth.uid() = id );

create policy "policy users_all2"
  on running2 for all
  with check ( auth.uid() = user_id );

create table todos (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users not null,
  title text,
  content text,
  is_completed boolean default false,
  inserted_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table todos enable row level security;

create policy "policy users_create_todos"
  on todos for insert
  with check ( auth.uid() = user_id );

create policy "policy users_view_their_own_todos"
  on todos for select
  using ( auth.uid() = user_id );

create policy "policy users_update_their_own_todos"
  on todos for update
  using ( auth.uid() = user_id );

create policy "policy users_delete_their_own_todos"
  on todos for delete
  using ( auth.uid() = user_id );

-- another way to create a policy (1st example)
CREATE POLICY "policy anon_read_all"
  ON "public"."todos"
  AS PERMISSIVE FOR SELECT
  TO public
  USING ( auth.role() = 'anon' );
-- alternative : auth.role() = 'anon'
-- alternative : (role() = 'anon'::text)
-- alternative : (is_completed = true)

-- another way to create a policy (2nd example)
CREATE POLICY "policy users_do_all_their_data" ON "public"."running2"
  AS PERMISSIVE FOR ALL
  TO public
  USING ( auth.uid() = user_id )
-- alternative : auth.uid() = user_id
-- alternative : (uid() = user_id)

-- rename a policy
BEGIN;
  ALTER POLICY "anon_read_all" ON "public"."todos"
  RENAME TO "public_read_all";
COMMIT;
```

## User Management Starter

```sql
-- create a table called profiles
create table profiles (
  id uuid references auth.users not null primary key,
  updated_at timestamp with time zone,
  username text unique,
  full_name text,
  avatar_url text,
  website text,

  constraint username_length check (char_length(username) >= 3)
);

-- enable RLS on profiles
alter table profiles enable row level security;

create policy "policy anon_read_all"
  on profiles for select
  using ( true );

create policy "policy users_insert_their_own_data"
  on profiles for insert
  with check ( auth.uid() = id );

create policy "policy users_update_their_own_data"
  on profiles for update
  using ( auth.uid() = id );

-- automatically creates a profile entry when a new user signs up
create function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, full_name, avatar_url)
  values (new.id, new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'avatar_url');
  return new;
end;
$$ language plpgsql security definer;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- set up Storage
insert into storage.buckets (id, name)
  values ('avatars', 'avatars');

-- set up access controls for storage.
create policy "policy public_view_avatars"
  on storage.objects for select
  using ( bucket_id = 'avatars' );

create policy "policy public_upload_avatars"
  on storage.objects for insert
  with check ( bucket_id = 'avatars' );

create policy "policy public_update_avatars"
  on storage.objects for update
  with check ( bucket_id = 'avatars' );
```

## Advanced Level

```sql
create policy "Only Blizzard staff can update leaderboard"
  on my_scores
  for update using (
    right(auth.jwt() ->> 'email', 13) = '@blizzard.com'
  );

-- add data
insert into my_scores(name, score, user_id)
values
  ('Paul', 100, '5a4365e7-7c7d-4eaf-a8ee-9ec9432917ca'),
  ('Paul', 200, '5a4365e7-7c7d-4eaf-a8ee-9ec9432917ca'),
  ('Leto', 50,  '9ec94326-2e2d-2ea2-22e3-3a535a4365e7');

begin;
  drop publication if exists supabase_realtime;
  create publication supabase_realtime;
commit;

alter publication supabase_realtime add table todo_profiles;
```

&nbsp;

# Coding in Next.js

- Next.js is a highly versatile framework offering pre-rendering at build time (SSG), server-side rendering at request time (SSR), API routes, and middleware edge-functions

- APIs will be automatically generated when you create your database tables

- Install several Supabase libraries

```bash
yarn add @supabase/supabase-js
yarn add @supabase/auth-helpers-react @supabase/auth-helpers-nextjs
yarn add @supabase/auth-ui-react
```

- Collect 2 environment variables

```env
NEXT_PUBLIC_SUPABASE_URL=
NEXT_PUBLIC_SUPABASE_ANON_KEY=
```

- Supabase client sets the user **session** in local storage

```bash
{
  "expires_at": 1670748631,
  "expires_in": 3338,
  "token_type": "bearer",
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJhdXRoZW50aWNhdGVkIiwiZXhwIjoxNjcwNzQ4NjMxLCJzdWIiOiJiYjJiYzliMS1mNmEyLTQ5MjEtYTIyYS05ODhiMjFjMDY0Y2QiLCJlbWFpbCI6ImlzYWFjbGlAbWFjLmNvbSIsInBob25lIjoiIiwiYXBwX21ldGFkYXRhIjp7InByb3ZpZGVyIjoiZW1haWwiLCJwcm92aWRlcnMiOlsiZW1haWwiXX0sInVzZXJfbWV0YWRhdGEiOnt9LCJyb2xlIjoiYXV0aGVudGljYXRlZCIsImFhbCI6ImFhbDEiLCJhbXIiOlt7Im1ldGhvZCI6InBhc3N3b3JkIiwidGltZXN0YW1wIjoxNjcwNzQ1MDMxfV0sInNlc3Npb25faWQiOiI3NDQzNGY2MS0xZGYxLTRjMTgtOGI5ZC1hOWMxN2NjYWE3OTAifQ.0mcYEjLpRNjKeN-o-olT2LZohCFHGik2_EXZaGONRnk",
  "refresh_token": "pKmP8zQj2TG9O1ybUIx8Ew",
  "provider_token": null,
  "provider_refresh_token": null,
  "user": {
    "id": "bb2bc9b1-f6a2-4921-a22a-988b21c064cd",
    "aud": "authenticated",
    "email": "isaacli@mac.com",
    "phone": "",
    "app_metadata": {
      "provider": "email",
      "providers": [
        "email"
      ]
    },
    "user_metadata": {},
    "role": "authenticated",
    "aal": "aal1",
    "amr": [
      {
        "method": "password",
        "timestamp": 1670745031
      }
    ],
    "session_id": "74434f61-1df1-4c18-8b9d-a9c17ccaa790"
  }
}
```

- Supabase documentation : [Part 2 : RLS](https://supabase.com/docs/learn/auth-deep-dive/auth-row-level-security), [YouTube](https://youtu.be/qY_iQ10IUhs), [Part 3 : Policies](https://supabase.com/docs/learn/auth-deep-dive/auth-policies), [YouTube](https://youtu.be/0LvCOlELs5U), [PostgeSQL Policies](https://www.postgresql.org/docs/12/sql-createpolicy.html), [PostgREST RLS](https://postgrest.org/en/v7.0.0/auth.html), [YouTube](https://youtu.be/0Fs96oZ4se0), [GitHub](https://github.com/supabase/supabase/tree/master/examples/user-management/nextjs-ts-user-management)

&nbsp;

```bash
curl -X POST 'https://gyhtmyvqhywrkzulcrwa.supabase.co/rest/v1/running2' \
-H "apikey: SUPABASE_KEY" \
-H "Authorization: Bearer SUPABASE_KEY" \
-H "Content-Type: application/json" \
-H "Prefer: return=minimal" \
-d '{ "some_column": "someValue", "other_column": "otherValue" }'

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJhdXRoZW50aWNhdGVkIiwiZXhwIjoxNjcwODI2NjQ4LCJzdWIiOiJiYjJiYzliMS1mNmEyLTQ5MjEtYTIyYS05ODhiMjFjMDY0Y2QiLCJlbWFpbCI6ImlzYWFjbGlAbWFjLmNvbSIsInBob25lIjoiIiwiYXBwX21ldGFkYXRhIjp7InByb3ZpZGVyIjoiZW1haWwiLCJwcm92aWRlcnMiOlsiZW1haWwiXX0sInVzZXJfbWV0YWRhdGEiOnt9LCJyb2xlIjoiYXV0aGVudGljYXRlZCIsImFhbCI6ImFhbDEiLCJhbXIiOlt7Im1ldGhvZCI6InBhc3N3b3JkIiwidGltZXN0YW1wIjoxNjcwODIzMDQ4fV0sInNlc3Npb25faWQiOiIyYWY3NmFkNy00MjNhLTRmYTUtYTc2MS05ZWI1MzJmMzhlY2UifQ.6YHkSNUzfrr9LAwNgEiipMxSCegeUnfvMRazygP1LUk
```

```js
const loggedInUserId = "d0714948"
let { data, error } = await supabase.from("users").select("user_id, name").eq("user_id", loggedInUserId)
```

```js
// auth.uid() extracts UID from JWT
user_id = auth.uid()
```

- your request will return the rows which pass the rule, even when you remove the filter from your middleware

```js
let { data, error } = await supabase.from("users").select("user_id, name")

// console.log(data)
// Still => { id: 'd0714948', name: 'Jane' }
```

```js
console.log(supabase.auth.signUp({ email, password }))

// the user access JWT is issued
console.log(
  supabase.auth.signIn({
    email: "lao.gimmie@gov.sg",
    password: "They_Live_1988!"
  })
)

// automatically plucks the access_token out of the URL and initiates a session
// retrieve the session to see if there is a valid session
console.log(supabase.auth.getSession())
```

&nbsp;

```bash
curl 'https://gyhtmyvqhywrkzulcrwa.supabase.co/rest/v1/jokes0?select=*' \
-H "apikey: SUPABASE_ANON_KEY" \
-H "Authorization: Bearer SUPABASE_ANON_KEY"
```

```js
const readLeaderboard = async () => {
  let { data, error } = await supabase.from("leaderboard").select("name, score").order("score", { ascending: false })

  if (error) {
    console.error(error)
    return
  }

  console.log(data)
}

// Writing
let { data, error } = await supabase.from("leaderboard").insert({ name: "Bob", score: 99999 })
```

- need to provide your site url in Auth > Settings on the dashboard. By default this is http://localhost:3000

```js
supabase.from("my_scores").select("*").then(console.log)
```

- only receive scores belonging to the current logged in user

```bash
curl 'https://sjvwsaokcugktsdaxxze.supabase.co/rest/v1/my_scores?select=*' \
-H "apikey: <ANON_KEY>" \
-H "Authorization: Bearer <ACCESS_TOKEN>"
```

Note that the anon key (or service role key) is always needed to get past the API gateway. This can be passed in the apikey header or in a query param named apikey. It is passed automatically in supabase-js as long as you used it to instantiate the client.

There are some more notes here on how to structure your schema to best integrate with the auth.users table.

Once you get the hang of policies you can start to get a little bit fancy. Let's say I work at Blizzard and I only want Blizzard staff members to be able to update people's high scores, I can write something like:

Supabase comes with two built-in helper functions: auth.uid() and auth.jwt().
